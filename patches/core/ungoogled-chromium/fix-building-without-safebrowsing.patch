# Additional changes to Inox's fix-building-without-safebrowsing.patch

--- a/chrome/browser/BUILD.gn
+++ b/chrome/browser/BUILD.gn
@@ -3775,9 +3775,6 @@ static_library("browser") {
       "download/offline_item_model_manager_factory.h",
       "enterprise/connectors/analysis/analysis_service_settings.cc",
       "enterprise/connectors/analysis/analysis_service_settings.h",
-      "enterprise/connectors/analysis/content_analysis_delegate.cc",
-      "enterprise/connectors/analysis/content_analysis_delegate.h",
-      "enterprise/connectors/analysis/content_analysis_delegate_base.h",
       "enterprise/connectors/analysis/content_analysis_dialog.cc",
       "enterprise/connectors/analysis/content_analysis_dialog.h",
       "enterprise/connectors/analysis/content_analysis_downloads_delegate.cc",
@@ -7198,9 +7195,14 @@ static_library("browser") {
       "//components/safe_browsing/content/browser:safe_browsing_blocking_page",
       "//components/safe_browsing/content/browser/download:download_stats",
       "//components/safe_browsing/content/common:file_type_policies",
-      "//components/safe_browsing/content/common/proto:download_file_types_proto",
+      # "//components/safe_browsing/content/common/proto:download_file_types_proto",
     ]
   }
+  # Use download_file_types_proto regardless of safe_browsing_mode, for
+  # now...
+  deps += [
+    "//components/safe_browsing/content/common/proto:download_file_types_proto",
+  ]
 
   if (!is_fuchsia) {
     sources += [
--- a/chrome/browser/accuracy_tips/accuracy_service_factory.cc
+++ b/chrome/browser/accuracy_tips/accuracy_service_factory.cc
@@ -48,10 +48,7 @@ KeyedService* AccuracyServiceFactory::Bu
     content::BrowserContext* browser_context) const {
   DCHECK(base::FeatureList::IsEnabled(safe_browsing::kAccuracyTipsFeature));
   Profile* profile = Profile::FromBrowserContext(browser_context);
-  auto sb_database =
-      g_browser_process->safe_browsing_service()
-          ? g_browser_process->safe_browsing_service()->database_manager()
-          : nullptr;
+  auto sb_database = nullptr;
   auto* history_service = HistoryServiceFactory::GetForProfile(
       profile, ServiceAccessType::IMPLICIT_ACCESS);
   auto delegate = std::make_unique<AccuracyServiceDelegate>(profile);
--- a/chrome/browser/chrome_content_browser_client.cc
+++ b/chrome/browser/chrome_content_browser_client.cc
@@ -4252,11 +4252,13 @@ ChromeContentBrowserClient::CreateThrott
                    &throttles);
 #endif
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (base::FeatureList::IsEnabled(safe_browsing::kDelayedWarnings)) {
     throttles.push_back(
         std::make_unique<safe_browsing::DelayedWarningNavigationThrottle>(
             handle));
   }
+#endif
 
 // TODO(crbug.com/1052397): Revisit the macro expression once build flag switch
 // of lacros-chrome is complete.
@@ -5657,26 +5659,7 @@ ChromeContentBrowserClient::GetSafeBrows
     const std::vector<std::string>& allowlist_domains) {
   DCHECK_CURRENTLY_ON(BrowserThread::IO);
 
-  // Should not bypass safe browsing check if the check is for enterprise
-  // lookup.
-  if (!safe_browsing_enabled_for_profile && !should_check_on_sb_disabled)
-    return nullptr;
-
-  // |safe_browsing_service_| may be unavailable in tests.
-  if (safe_browsing_service_ && !safe_browsing_url_checker_delegate_) {
-    safe_browsing_url_checker_delegate_ =
-        base::MakeRefCounted<safe_browsing::UrlCheckerDelegateImpl>(
-            safe_browsing_service_->database_manager(),
-            safe_browsing_service_->ui_manager());
-  }
-
-  // Update allowlist domains.
-  if (safe_browsing_url_checker_delegate_) {
-    safe_browsing_url_checker_delegate_->SetPolicyAllowlistDomains(
-        allowlist_domains);
-  }
-
-  return safe_browsing_url_checker_delegate_;
+  return nullptr;
 }
 
 safe_browsing::RealTimeUrlLookupServiceBase*
@@ -5697,11 +5680,6 @@ ChromeContentBrowserClient::GetUrlLookup
         GetForProfile(profile);
   }
 #endif
-
-  if (is_consumer_lookup_enabled) {
-    return safe_browsing::RealTimeUrlLookupServiceFactory::GetForProfile(
-        profile);
-  }
   return nullptr;
 }
 
--- a/chrome/browser/chrome_content_browser_client_receiver_bindings.cc
+++ b/chrome/browser/chrome_content_browser_client_receiver_bindings.cc
@@ -143,45 +143,6 @@ void MaybeCreateSafeBrowsingForRenderer(
         const std::vector<std::string>& allowlist_domains)>
         get_checker_delegate,
     mojo::PendingReceiver<safe_browsing::mojom::SafeBrowsing> receiver) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-
-  content::RenderProcessHost* render_process_host =
-      content::RenderProcessHost::FromID(process_id);
-  if (!render_process_host)
-    return;
-
-  PrefService* pref_service =
-      Profile::FromBrowserContext(render_process_host->GetBrowserContext())
-          ->GetPrefs();
-
-  std::vector<std::string> allowlist_domains =
-      safe_browsing::GetURLAllowlistByPolicy(pref_service);
-
-  // Log the size of the domains to make sure copying them is
-  // not too expensive.
-  if (allowlist_domains.size() > 0) {
-    int total_size = 0;
-    for (const auto& domains : allowlist_domains) {
-      total_size += domains.size();
-    }
-    base::UmaHistogramCounts10000(
-        "SafeBrowsing.Policy.AllowlistDomainsTotalSize", total_size);
-  }
-
-  bool safe_browsing_enabled =
-      safe_browsing::IsSafeBrowsingEnabled(*pref_service);
-  content::GetIOThreadTaskRunner({})->PostTask(
-      FROM_HERE,
-      base::BindOnce(
-          &safe_browsing::MojoSafeBrowsingImpl::MaybeCreate, process_id,
-          resource_context,
-          base::BindRepeating(get_checker_delegate, safe_browsing_enabled,
-                              // Navigation initiated from renderer should never
-                              // check when safe browsing is disabled, because
-                              // enterprise check only supports mainframe URL.
-                              /*should_check_on_sb_disabled=*/false,
-                              allowlist_domains),
-          std::move(receiver)));
 }
 
 // BadgeManager is not used for Android.
--- a/chrome/browser/component_updater/chrome_client_side_phishing_component_installer.cc
+++ b/chrome/browser/component_updater/chrome_client_side_phishing_component_installer.cc
@@ -30,20 +30,6 @@ namespace {
 
 void LoadFromDisk(const base::FilePath& pb_path,
                   const base::FilePath& visual_tflite_model_path) {
-  if (pb_path.empty())
-    return;
-
-  std::string binary_pb;
-  if (!base::ReadFileToString(pb_path, &binary_pb))
-    binary_pb.clear();
-
-  base::File visual_tflite_model(visual_tflite_model_path,
-                                 base::File::FLAG_OPEN | base::File::FLAG_READ);
-
-  // The ClientSidePhishingModel singleton will react appropriately if the
-  // |binary_pb| is empty or |visual_tflite_model| is invalid.
-  safe_browsing::ClientSidePhishingModel::GetInstance()
-      ->PopulateFromDynamicUpdate(binary_pb, std::move(visual_tflite_model));
 }
 
 void PopulateModelFromFiles(const base::FilePath& install_dir) {
@@ -57,9 +43,6 @@ void PopulateModelFromFiles(const base::
 update_client::InstallerAttributes GetInstallerAttributes() {
   update_client::InstallerAttributes attributes;
 
-  // Pass the tag parameter to the installer as the "tag" attribute; it will
-  // be used to choose which binary is downloaded.
-  attributes["tag"] = safe_browsing::GetClientSideDetectionTag();
   return attributes;
 }
 
--- a/chrome/browser/download/chrome_download_manager_delegate.cc
+++ b/chrome/browser/download/chrome_download_manager_delegate.cc
@@ -134,7 +134,6 @@ using content::DownloadManager;
 using download::DownloadItem;
 using download::DownloadPathReservationTracker;
 using download::PathValidationResult;
-using safe_browsing::DownloadFileType;
 using safe_browsing::DownloadProtectionService;
 using ConnectionType = net::NetworkChangeNotifier::ConnectionType;
 
@@ -1526,8 +1525,6 @@ void ChromeDownloadManagerDelegate::OnDo
     if (item->GetOriginalMimeType() == "application/x-x509-user-cert")
       DownloadItemModel(item).SetShouldPreferOpeningInBrowser(true);
 #endif
-
-    DownloadItemModel(item).SetDangerLevel(target_info->danger_level);
   }
   if (ShouldBlockFile(target_info->danger_type, item)) {
     MaybeReportDangerousDownloadBlocked(
@@ -1683,9 +1680,11 @@ void ChromeDownloadManagerDelegate::Mayb
   if (!download->GetAutoOpened()) {
     download::DownloadContent download_content =
         download::DownloadContentFromMimeType(download->GetMimeType(), false);
+#if BUILDFLAG(FULL_SAFE_BROWSING)
     safe_browsing::RecordDownloadOpened(
         download->GetDangerType(), download_content, base::Time::Now(),
         download->GetEndTime(), show_download_in_folder);
+#endif
   }
 }
 
@@ -1756,6 +1755,7 @@ void ChromeDownloadManagerDelegate::Chec
   DCHECK(download_item);
   DCHECK(download_item->IsSavePackageDownload());
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 #if defined(OS_WIN) || defined(OS_LINUX) || defined(OS_CHROMEOS) || \
     defined(OS_MAC)
   if (!base::FeatureList::IsEnabled(
@@ -1788,6 +1788,7 @@ void ChromeDownloadManagerDelegate::Chec
     }
   }
 #endif
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
   std::move(callback).Run(true);
 }
 
--- a/chrome/browser/download/download_stats.cc
+++ b/chrome/browser/download/download_stats.cc
@@ -8,6 +8,7 @@
 #include "base/metrics/user_metrics.h"
 #include "base/notreached.h"
 #include "components/profile_metrics/browser_profile_type.h"
+#include "components/safe_browsing/buildflags.h"
 #include "components/safe_browsing/content/browser/download/download_stats.h"
 
 void RecordDownloadCount(ChromeDownloadCountTypes type) {
@@ -27,8 +28,10 @@ void RecordDangerousDownloadWarningShown
     bool has_user_gesture) {
   base::UmaHistogramEnumeration("Download.ShowedDownloadWarning", danger_type,
                                 download::DOWNLOAD_DANGER_TYPE_MAX);
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   safe_browsing::RecordDangerousDownloadWarningShown(
       danger_type, file_path, is_https, has_user_gesture);
+#endif
 }
 
 void RecordOpenedDangerousConfirmDialog(
--- a/chrome/browser/download/download_target_determiner.cc
+++ b/chrome/browser/download/download_target_determiner.cc
@@ -872,11 +872,13 @@ void DownloadTargetDeterminer::CheckVisi
     bool visited_referrer_before) {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
   DCHECK_EQ(STATE_DETERMINE_INTERMEDIATE_PATH, next_state_);
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::RecordDownloadFileTypeAttributes(
       safe_browsing::FileTypePolicies::GetInstance()->GetFileDangerLevel(
           virtual_path_.BaseName()),
       download_->HasUserGesture(), visited_referrer_before,
       GetLastDownloadBypassTimestamp());
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
   danger_level_ = GetDangerLevel(
       visited_referrer_before ? VISITED_REFERRER : NO_VISITS_TO_REFERRER);
   if (danger_level_ != DownloadFileType::NOT_DANGEROUS &&
@@ -1111,6 +1113,7 @@ DownloadFileType::DangerLevel DownloadTa
 
 absl::optional<base::Time>
 DownloadTargetDeterminer::GetLastDownloadBypassTimestamp() const {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::SafeBrowsingMetricsCollector* metrics_collector =
       safe_browsing::SafeBrowsingMetricsCollectorFactory::GetForProfile(
           GetProfile());
@@ -1119,6 +1122,9 @@ DownloadTargetDeterminer::GetLastDownloa
                                  safe_browsing::SafeBrowsingMetricsCollector::
                                      EventType::DANGEROUS_DOWNLOAD_BYPASS)
                            : absl::nullopt;
+#else
+  return absl::nullopt;
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 }
 
 void DownloadTargetDeterminer::OnDownloadDestroyed(
--- a/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc
+++ b/chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.cc
@@ -32,14 +32,12 @@
 #include "chrome/browser/safe_browsing/cloud_content_scanning/binary_upload_service_factory.h"
 #include "chrome/browser/safe_browsing/cloud_content_scanning/deep_scanning_utils.h"
 #include "chrome/browser/safe_browsing/cloud_content_scanning/file_analysis_request.h"
-#include "chrome/browser/safe_browsing/download_protection/check_client_download_request.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/enterprise/common/proto/connectors.pb.h"
 #include "components/policy/core/browser/url_util.h"
 #include "components/policy/core/common/chrome_schema.h"
 #include "components/prefs/pref_service.h"
 #include "components/safe_browsing/core/common/features.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 #include "components/url_matcher/url_matcher.h"
 #include "content/public/browser/web_contents.h"
 #include "crypto/secure_hash.h"
--- a/chrome/browser/enterprise/connectors/connectors_service.cc
+++ b/chrome/browser/enterprise/connectors/connectors_service.cc
@@ -459,19 +459,6 @@ absl::optional<std::string> ConnectorsSe
   return absl::nullopt;
 }
 
-safe_browsing::EnterpriseRealTimeUrlCheckMode
-ConnectorsService::GetAppliedRealTimeUrlCheck() const {
-  if (!ConnectorsEnabled() ||
-      !GetDmToken(prefs::kSafeBrowsingEnterpriseRealTimeUrlCheckScope)
-           .has_value()) {
-    return safe_browsing::REAL_TIME_CHECK_DISABLED;
-  }
-
-  return static_cast<safe_browsing::EnterpriseRealTimeUrlCheckMode>(
-      Profile::FromBrowserContext(context_)->GetPrefs()->GetInteger(
-          prefs::kSafeBrowsingEnterpriseRealTimeUrlCheckMode));
-}
-
 ConnectorsManager* ConnectorsService::ConnectorsManagerForTesting() {
   return connectors_manager_.get();
 }
--- a/chrome/browser/enterprise/connectors/connectors_service.h
+++ b/chrome/browser/enterprise/connectors/connectors_service.h
@@ -14,7 +14,6 @@
 #include "components/keyed_service/content/browser_context_keyed_service_factory.h"
 #include "components/keyed_service/core/keyed_service.h"
 #include "components/policy/core/common/policy_types.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 #include "content/public/browser/browser_context.h"
 
 namespace base {
@@ -79,12 +78,6 @@ class ConnectorsService : public KeyedSe
   // is no token to use.
   absl::optional<std::string> GetDMTokenForRealTimeUrlCheck() const;
 
-  // Returns the value to used by the enterprise real-time URL check Connector
-  // if it is set and if the scope it's set at has a valid browser-profile
-  // affiliation.
-  safe_browsing::EnterpriseRealTimeUrlCheckMode GetAppliedRealTimeUrlCheck()
-      const;
-
   // Returns the CBCM domain or profile domain that enables connector policies.
   // If both set Connector policies, the CBCM domain is returned as it has
   // precedence.
--- a/chrome/browser/enterprise/signals/context_info_fetcher.cc
+++ b/chrome/browser/enterprise/signals/context_info_fetcher.cc
@@ -199,7 +199,6 @@ void ContextInfoFetcher::Fetch(ContextIn
       GetAnalysisConnectorProviders(enterprise_connectors::FILE_DOWNLOADED);
   info.on_bulk_data_entry_providers =
       GetAnalysisConnectorProviders(enterprise_connectors::BULK_DATA_ENTRY);
-  info.realtime_url_check_mode = GetRealtimeUrlCheckMode();
   info.on_security_event_providers = GetOnSecurityEventProviders();
   info.browser_version = version_info::GetVersionNumber();
   info.site_isolation_enabled =
@@ -257,11 +256,6 @@ std::vector<std::string> ContextInfoFetc
   return connectors_service_->GetAnalysisServiceProviderNames(connector);
 }
 
-safe_browsing::EnterpriseRealTimeUrlCheckMode
-ContextInfoFetcher::GetRealtimeUrlCheckMode() {
-  return connectors_service_->GetAppliedRealTimeUrlCheck();
-}
-
 std::vector<std::string> ContextInfoFetcher::GetOnSecurityEventProviders() {
   return connectors_service_->GetReportingServiceProviderNames(
       enterprise_connectors::ReportingConnector::SECURITY_EVENT);
--- a/chrome/browser/enterprise/signals/context_info_fetcher.h
+++ b/chrome/browser/enterprise/signals/context_info_fetcher.h
@@ -6,13 +6,13 @@
 #define CHROME_BROWSER_ENTERPRISE_SIGNALS_CONTEXT_INFO_FETCHER_H_
 
 #include <string>
+#include <memory>
 #include <vector>
 
 #include "base/callback_forward.h"
 #include "base/memory/raw_ptr.h"
 #include "build/build_config.h"
 #include "chrome/browser/enterprise/signals/signals_common.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 
 namespace content {
 class BrowserContext;
@@ -38,7 +38,6 @@ struct ContextInfo {
   std::vector<std::string> on_file_downloaded_providers;
   std::vector<std::string> on_bulk_data_entry_providers;
   std::vector<std::string> on_security_event_providers;
-  safe_browsing::EnterpriseRealTimeUrlCheckMode realtime_url_check_mode;
   std::string browser_version;
   safe_browsing::SafeBrowsingState safe_browsing_protection_level;
   bool site_isolation_enabled;
@@ -89,7 +88,6 @@ class ContextInfoFetcher {
   std::vector<std::string> GetAnalysisConnectorProviders(
       enterprise_connectors::AnalysisConnector connector);
 
-  safe_browsing::EnterpriseRealTimeUrlCheckMode GetRealtimeUrlCheckMode();
 
   std::vector<std::string> GetOnSecurityEventProviders();
 
--- a/chrome/browser/extensions/BUILD.gn
+++ b/chrome/browser/extensions/BUILD.gn
@@ -640,8 +640,6 @@ static_library("extensions") {
     "menu_manager_factory.h",
     "navigation_observer.cc",
     "navigation_observer.h",
-    "omaha_attributes_handler.cc",
-    "omaha_attributes_handler.h",
     "pack_extension_job.cc",
     "pack_extension_job.h",
     "pending_extension_info.cc",
--- a/chrome/browser/extensions/api/enterprise_reporting_private/enterprise_reporting_private_api.cc
+++ b/chrome/browser/extensions/api/enterprise_reporting_private/enterprise_reporting_private_api.cc
@@ -72,17 +72,8 @@ api::enterprise_reporting_private::Conte
           : nullptr;
   info.os_firewall = ToInfoSettingValue(signals.os_firewall);
   info.system_dns_servers = std::move(signals.system_dns_servers);
-  switch (signals.realtime_url_check_mode) {
-    case safe_browsing::REAL_TIME_CHECK_DISABLED:
       info.realtime_url_check_mode = extensions::api::
           enterprise_reporting_private::REALTIME_URL_CHECK_MODE_DISABLED;
-      break;
-    case safe_browsing::REAL_TIME_CHECK_FOR_MAINFRAME_ENABLED:
-      info.realtime_url_check_mode =
-          extensions::api::enterprise_reporting_private::
-              REALTIME_URL_CHECK_MODE_ENABLED_MAIN_FRAME;
-      break;
-  }
   info.browser_version = std::move(signals.browser_version);
   info.built_in_dns_client_enabled = signals.built_in_dns_client_enabled;
 
--- a/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
+++ b/chrome/browser/extensions/api/safe_browsing_private/safe_browsing_private_event_router.cc
@@ -340,6 +340,7 @@ void SafeBrowsingPrivateEventRouter::OnD
     event_router_->BroadcastEvent(std::move(extension_event));
   }
 
+#if defined(FULL_SAFE_BROWSING)
   absl::optional<enterprise_connectors::ReportingSettings> settings =
       GetReportingSettings();
   if (!settings.has_value() ||
@@ -370,6 +371,7 @@ void SafeBrowsingPrivateEventRouter::OnD
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnSecurityInterstitialShown(
@@ -397,6 +399,7 @@ void SafeBrowsingPrivateEventRouter::OnS
     event_router_->BroadcastEvent(std::move(extension_event));
   }
 
+#if defined(FULL_SAFE_BROWSING)
   absl::optional<enterprise_connectors::ReportingSettings> settings =
       GetReportingSettings();
   if (!settings.has_value() ||
@@ -420,6 +423,7 @@ void SafeBrowsingPrivateEventRouter::OnS
 
   ReportRealtimeEvent(kKeyInterstitialEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnSecurityInterstitialProceeded(
@@ -447,6 +451,7 @@ void SafeBrowsingPrivateEventRouter::OnS
     event_router_->BroadcastEvent(std::move(extension_event));
   }
 
+#if defined(FULL_SAFE_BROWSING)
   absl::optional<enterprise_connectors::ReportingSettings> settings =
       GetReportingSettings();
   if (!settings.has_value() ||
@@ -466,6 +471,7 @@ void SafeBrowsingPrivateEventRouter::OnS
 
   ReportRealtimeEvent(kKeyInterstitialEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnAnalysisConnectorResult(
@@ -479,6 +485,7 @@ void SafeBrowsingPrivateEventRouter::OnA
     const enterprise_connectors::ContentAnalysisResponse::Result& result,
     const int64_t content_size,
     safe_browsing::EventResult event_result) {
+#if defined(FULL_SAFE_BROWSING)
   if (result.tag() == "malware") {
     DCHECK_EQ(1, result.triggered_rules().size());
     OnDangerousDeepScanningResult(
@@ -490,6 +497,7 @@ void SafeBrowsingPrivateEventRouter::OnA
     OnSensitiveDataEvent(url, file_name, download_digest_sha256, mime_type,
                          trigger, scan_id, result, content_size, event_result);
   }
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnDangerousDeepScanningResult(
@@ -505,6 +513,7 @@ void SafeBrowsingPrivateEventRouter::OnD
     const std::string& malware_category,
     const std::string& evidence_locker_filepath,
     const std::string& scan_id) {
+#if defined(FULL_SAFE_BROWSING)
   absl::optional<enterprise_connectors::ReportingSettings> settings =
       GetReportingSettings();
   if (!settings.has_value() ||
@@ -542,6 +551,7 @@ void SafeBrowsingPrivateEventRouter::OnD
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnSensitiveDataEvent(
@@ -554,6 +564,7 @@ void SafeBrowsingPrivateEventRouter::OnS
     const enterprise_connectors::ContentAnalysisResponse::Result& result,
     const int64_t content_size,
     safe_browsing::EventResult event_result) {
+#if defined(FULL_SAFE_BROWSING)
   absl::optional<enterprise_connectors::ReportingSettings> settings =
       GetReportingSettings();
   if (!settings.has_value() ||
@@ -586,6 +597,7 @@ void SafeBrowsingPrivateEventRouter::OnS
 
   ReportRealtimeEvent(kKeySensitiveDataEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnAnalysisConnectorWarningBypassed(
@@ -598,6 +610,7 @@ void SafeBrowsingPrivateEventRouter::OnA
     safe_browsing::DeepScanAccessPoint access_point,
     const enterprise_connectors::ContentAnalysisResponse::Result& result,
     const int64_t content_size) {
+#if defined(FULL_SAFE_BROWSING)
   absl::optional<enterprise_connectors::ReportingSettings> settings =
       GetReportingSettings();
   if (!settings.has_value() ||
@@ -630,6 +643,7 @@ void SafeBrowsingPrivateEventRouter::OnA
 
   ReportRealtimeEvent(kKeySensitiveDataEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnUnscannedFileEvent(
@@ -642,6 +656,7 @@ void SafeBrowsingPrivateEventRouter::OnU
     const std::string& reason,
     const int64_t content_size,
     safe_browsing::EventResult event_result) {
+#if defined(FULL_SAFE_BROWSING)
   absl::optional<enterprise_connectors::ReportingSettings> settings =
       GetReportingSettings();
   if (!settings.has_value() ||
@@ -668,6 +683,7 @@ void SafeBrowsingPrivateEventRouter::OnU
 
   ReportRealtimeEvent(kKeyUnscannedFileEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnDangerousDownloadEvent(
@@ -693,6 +709,7 @@ void SafeBrowsingPrivateEventRouter::OnD
     const std::string& scan_id,
     const int64_t content_size,
     safe_browsing::EventResult event_result) {
+#if defined(FULL_SAFE_BROWSING)
   absl::optional<enterprise_connectors::ReportingSettings> settings =
       GetReportingSettings();
   if (!settings.has_value() ||
@@ -723,6 +740,7 @@ void SafeBrowsingPrivateEventRouter::OnD
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
+#endif
 }
 
 void SafeBrowsingPrivateEventRouter::OnDangerousDownloadWarningBypassed(
@@ -746,6 +764,7 @@ void SafeBrowsingPrivateEventRouter::OnD
     const std::string& mime_type,
     const std::string& scan_id,
     const int64_t content_size) {
+#if defined(FULL_SAFE_BROWSING)
   absl::optional<enterprise_connectors::ReportingSettings> settings =
       GetReportingSettings();
   if (!settings.has_value() ||
@@ -776,6 +795,7 @@ void SafeBrowsingPrivateEventRouter::OnD
 
   ReportRealtimeEvent(kKeyDangerousDownloadEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnLoginEvent(
@@ -783,6 +803,7 @@ void SafeBrowsingPrivateEventRouter::OnL
     bool is_federated,
     const url::Origin& federated_origin,
     const std::u16string& username) {
+#if defined(FULL_SAFE_BROWSING)
   absl::optional<enterprise_connectors::ReportingSettings> settings =
       GetReportingSettings();
   if (!settings.has_value() ||
@@ -800,11 +821,13 @@ void SafeBrowsingPrivateEventRouter::OnL
 
   ReportRealtimeEvent(kKeyLoginEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 void SafeBrowsingPrivateEventRouter::OnPasswordBreach(
     const std::string& trigger,
     const std::vector<std::pair<GURL, std::u16string>>& identities) {
+#if defined(FULL_SAFE_BROWSING)
   absl::optional<enterprise_connectors::ReportingSettings> settings =
       GetReportingSettings();
   if (!settings.has_value() ||
@@ -827,6 +850,7 @@ void SafeBrowsingPrivateEventRouter::OnP
 
   ReportRealtimeEvent(kKeyPasswordBreachEvent, std::move(settings.value()),
                       std::move(event));
+#endif // FULL_SAFE_BROWSING
 }
 
 // static
@@ -1101,7 +1125,11 @@ void SafeBrowsingPrivateEventRouter::Rep
 }
 
 std::string SafeBrowsingPrivateEventRouter::GetProfileUserName() const {
+#if defined(FULL_SAFE_BROWSING)
   return safe_browsing::GetProfileEmail(identity_manager_);
+#else
+  return "";
+#endif
 }
 
 #if BUILDFLAG(IS_CHROMEOS_ASH)
--- a/chrome/browser/extensions/chrome_extensions_browser_client.cc
+++ b/chrome/browser/extensions/chrome_extensions_browser_client.cc
@@ -42,9 +42,6 @@
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/profiles/profile_manager.h"
 #include "chrome/browser/renderer_host/chrome_navigation_ui_data.h"
-#include "chrome/browser/safe_browsing/extension_telemetry/extension_telemetry_service.h"
-#include "chrome/browser/safe_browsing/extension_telemetry/extension_telemetry_service_factory.h"
-#include "chrome/browser/safe_browsing/extension_telemetry/tabs_execute_script_signal.h"
 #include "chrome/browser/task_manager/web_contents_tags.h"
 #include "chrome/browser/ui/webui/chrome_web_ui_controller_factory.h"
 #include "chrome/common/channel_info.h"
@@ -579,15 +576,6 @@ void ChromeExtensionsBrowserClient::Noti
     content::BrowserContext* context,
     const ExtensionId& extension_id,
     const std::string& code) const {
-  auto* telemetry_service =
-      safe_browsing::ExtensionTelemetryServiceFactory::GetForProfile(
-          Profile::FromBrowserContext(context));
-  if (!telemetry_service || !telemetry_service->enabled())
-    return;
-
-  auto signal = std::make_unique<safe_browsing::TabsExecuteScriptSignal>(
-      extension_id, code);
-  telemetry_service->AddSignal(std::move(signal));
 }
 
 // static
--- a/chrome/browser/extensions/extension_service.cc
+++ b/chrome/browser/extensions/extension_service.cc
@@ -52,7 +52,6 @@
 #include "chrome/browser/extensions/forced_extensions/install_stage_tracker.h"
 #include "chrome/browser/extensions/install_verifier.h"
 #include "chrome/browser/extensions/installed_loader.h"
-#include "chrome/browser/extensions/omaha_attributes_handler.h"
 #include "chrome/browser/extensions/pending_extension_manager.h"
 #include "chrome/browser/extensions/permissions_updater.h"
 #include "chrome/browser/extensions/shared_module_service.h"
@@ -203,10 +202,6 @@ void ExtensionService::AddProviderForTes
 
 void ExtensionService::BlocklistExtensionForTest(
     const std::string& extension_id) {
-  blocklist_prefs::SetSafeBrowsingExtensionBlocklistState(
-      extension_id, BitMapBlocklistState::BLOCKLISTED_MALWARE,
-      extension_prefs_);
-  OnBlocklistStateAdded(extension_id);
 }
 
 bool ExtensionService::OnExternalExtensionUpdateUrlFound(
@@ -369,7 +364,6 @@ ExtensionService::ExtensionService(Profi
       safe_browsing_verdict_handler_(extension_prefs,
                                      ExtensionRegistry::Get(profile),
                                      this),
-      omaha_attributes_handler_(extension_prefs, this),
       registry_(ExtensionRegistry::Get(profile)),
       pending_extension_manager_(profile),
       install_directory_(install_directory),
@@ -857,100 +851,6 @@ bool ExtensionService::IsExtensionEnable
   return extension_registrar_.IsExtensionEnabled(extension_id);
 }
 
-void ExtensionService::PerformActionBasedOnOmahaAttributes(
-    const std::string& extension_id,
-    const base::Value& attributes) {
-  DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  omaha_attributes_handler_.PerformActionBasedOnOmahaAttributes(extension_id,
-                                                                attributes);
-  allowlist_.PerformActionBasedOnOmahaAttributes(extension_id, attributes);
-  // Show an error for the newly blocklisted extension.
-  error_controller_->ShowErrorIfNeeded();
-}
-
-void ExtensionService::OnGreylistStateRemoved(const std::string& extension_id) {
-  bool is_on_sb_list = (blocklist_prefs::GetSafeBrowsingExtensionBlocklistState(
-                            extension_id, extension_prefs_) !=
-                        BitMapBlocklistState::NOT_BLOCKLISTED);
-  bool is_on_omaha_list =
-      blocklist_prefs::HasAnyOmahaGreylistState(extension_id, extension_prefs_);
-  if (is_on_sb_list || is_on_omaha_list) {
-    return;
-  }
-  // Clear all acknowledged states so the extension will still get disabled if
-  // it is added to the greylist again.
-  blocklist_prefs::ClearAcknowledgedGreylistStates(extension_id,
-                                                   extension_prefs_);
-  RemoveDisableReasonAndMaybeEnable(extension_id,
-                                    disable_reason::DISABLE_GREYLIST);
-}
-
-void ExtensionService::OnGreylistStateAdded(const std::string& extension_id,
-                                            BitMapBlocklistState new_state) {
-#if DCHECK_IS_ON()
-  bool has_new_state_on_sb_list =
-      (blocklist_prefs::GetSafeBrowsingExtensionBlocklistState(
-           extension_id, extension_prefs_) == new_state);
-  bool has_new_state_on_omaha_list = blocklist_prefs::HasOmahaBlocklistState(
-      extension_id, new_state, extension_prefs_);
-  DCHECK(has_new_state_on_sb_list || has_new_state_on_omaha_list);
-#endif
-  if (blocklist_prefs::HasAcknowledgedBlocklistState(extension_id, new_state,
-                                                     extension_prefs_)) {
-    // If the extension is already acknowledged, don't disable it again
-    // because it can be already re-enabled by the user. This could happen if
-    // the extension is added to the SafeBrowsing blocklist, and then
-    // subsequently marked by Omaha. In this case, we don't want to disable the
-    // extension twice.
-    return;
-  }
-
-  // Set the current greylist states to acknowledge immediately because the
-  // extension is disabled silently. Clear the other acknowledged state because
-  // when the state changes to another greylist state in the future, we'd like
-  // to disable the extension again.
-  blocklist_prefs::UpdateCurrentGreylistStatesAsAcknowledged(extension_id,
-                                                             extension_prefs_);
-  DisableExtension(extension_id, disable_reason::DISABLE_GREYLIST);
-}
-
-void ExtensionService::OnBlocklistStateRemoved(
-    const std::string& extension_id) {
-  if (blocklist_prefs::IsExtensionBlocklisted(extension_id, extension_prefs_)) {
-    return;
-  }
-
-  // Clear acknowledged state.
-  blocklist_prefs::RemoveAcknowledgedBlocklistState(
-      extension_id, BitMapBlocklistState::BLOCKLISTED_MALWARE,
-      extension_prefs_);
-
-  scoped_refptr<const Extension> extension =
-      registry_->blocklisted_extensions().GetByID(extension_id);
-  DCHECK(extension);
-  registry_->RemoveBlocklisted(extension_id);
-  AddExtension(extension.get());
-}
-
-void ExtensionService::OnBlocklistStateAdded(const std::string& extension_id) {
-  DCHECK(
-      blocklist_prefs::IsExtensionBlocklisted(extension_id, extension_prefs_));
-  // The extension was already acknowledged by the user, it should already be in
-  // the unloaded state.
-  if (blocklist_prefs::HasAcknowledgedBlocklistState(
-          extension_id, BitMapBlocklistState::BLOCKLISTED_MALWARE,
-          extension_prefs_)) {
-    DCHECK(base::Contains(registry_->blocklisted_extensions().GetIDs(),
-                          extension_id));
-    return;
-  }
-
-  scoped_refptr<const Extension> extension =
-      registry_->GetInstalledExtension(extension_id);
-  registry_->AddBlocklisted(extension);
-  UnloadExtension(extension_id, UnloadedExtensionReason::BLOCKLIST);
-}
-
 void ExtensionService::RemoveDisableReasonAndMaybeEnable(
     const std::string& extension_id,
     disable_reason::DisableReason reason_to_remove) {
--- a/chrome/browser/extensions/extension_service.h
+++ b/chrome/browser/extensions/extension_service.h
@@ -25,7 +25,6 @@
 #include "chrome/browser/extensions/forced_extensions/force_installed_metrics.h"
 #include "chrome/browser/extensions/forced_extensions/force_installed_tracker.h"
 #include "chrome/browser/extensions/install_gate.h"
-#include "chrome/browser/extensions/omaha_attributes_handler.h"
 #include "chrome/browser/extensions/pending_extension_manager.h"
 #include "chrome/browser/extensions/safe_browsing_verdict_handler.h"
 #include "chrome/browser/profiles/profile_manager.h"
@@ -271,40 +270,11 @@ class ExtensionService : public Extensio
   // nothing.
   void EnableExtension(const std::string& extension_id);
 
-  // Takes Safe Browsing and Omaha blocklist states into account and decides
-  // whether to remove greylist disabled reason. Called when a greylisted
-  // state is removed from the Safe Browsing blocklist or Omaha blocklist. Also
-  // clears all acknowledged states if the greylist disabled reason is removed.
-  void OnGreylistStateRemoved(const std::string& extension_id);
-
-  // Takes acknowledged blocklist states into account and decides whether to
-  // disable the greylisted extension. Called when a new greylisted state is
-  // added to the Safe Browsing blocklist or Omaha blocklist.
-  void OnGreylistStateAdded(const std::string& extension_id,
-                            BitMapBlocklistState new_state);
-
-  // Takes Safe Browsing and Omaha malware blocklist states into account and
-  // decides whether to remove the extension from the blocklist and reload it.
-  // Called when a blocklisted extension is removed from the Safe Browsing
-  // malware blocklist or Omaha malware blocklist. Also clears the acknowledged
-  // state if the extension is reloaded.
-  void OnBlocklistStateRemoved(const std::string& extension_id);
-
-  // Takes acknowledged malware blocklist state into account and decides whether
-  // to add the extension to the blocklist and unload it. Called when the
-  // extension is added to the Safe Browsing malware blocklist or the Omaha
-  // malware blocklist.
-  void OnBlocklistStateAdded(const std::string& extension_id);
-
   // Removes the disable reason and enable the extension if there are no disable
   // reasons left and is not blocked for another reason.
   void RemoveDisableReasonAndMaybeEnable(const std::string& extension_id,
                                          disable_reason::DisableReason reason);
 
-  // Performs action based on Omaha attributes for the extension.
-  void PerformActionBasedOnOmahaAttributes(const std::string& extension_id,
-                                           const base::Value& attributes);
-
   // Disables the extension. If the extension is already disabled, just adds
   // the |disable_reasons| (a bitmask of disable_reason::DisableReason - there
   // can be multiple DisableReasons e.g. when an extension comes in disabled
@@ -640,8 +610,6 @@ class ExtensionService : public Extensio
 
   SafeBrowsingVerdictHandler safe_browsing_verdict_handler_;
 
-  OmahaAttributesHandler omaha_attributes_handler_;
-
   // Sets of enabled/disabled/terminated/blocklisted extensions. Not owned.
   raw_ptr<ExtensionRegistry> registry_ = nullptr;
 
--- a/chrome/browser/extensions/extension_system_impl.cc
+++ b/chrome/browser/extensions/extension_system_impl.cc
@@ -465,8 +465,6 @@ void ExtensionSystemImpl::InstallUpdate(
 void ExtensionSystemImpl::PerformActionBasedOnOmahaAttributes(
     const std::string& extension_id,
     const base::Value& attributes) {
-  extension_service()->PerformActionBasedOnOmahaAttributes(extension_id,
-                                                           attributes);
 }
 
 bool ExtensionSystemImpl::FinishDelayedInstallationIfReady(
--- a/chrome/browser/extensions/omaha_attributes_handler.cc
+++ b/chrome/browser/extensions/omaha_attributes_handler.cc
@@ -86,87 +86,4 @@ OmahaAttributesHandler::OmahaAttributesH
     : extension_prefs_(extension_prefs),
       extension_service_(extension_service) {}
 
-void OmahaAttributesHandler::PerformActionBasedOnOmahaAttributes(
-    const ExtensionId& extension_id,
-    const base::Value& attributes) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  HandleMalwareOmahaAttribute(extension_id, attributes);
-  HandleGreylistOmahaAttribute(
-      extension_id, attributes,
-      extensions_features::kDisablePolicyViolationExtensionsRemotely,
-      BitMapBlocklistState::BLOCKLISTED_CWS_POLICY_VIOLATION,
-      ExtensionUpdateCheckDataKey::kPolicyViolation);
-  HandleGreylistOmahaAttribute(
-      extension_id, attributes,
-      extensions_features::kDisablePotentiallyUwsExtensionsRemotely,
-      BitMapBlocklistState::BLOCKLISTED_POTENTIALLY_UNWANTED,
-      ExtensionUpdateCheckDataKey::kPotentiallyUWS);
-}
-
-void OmahaAttributesHandler::HandleMalwareOmahaAttribute(
-    const ExtensionId& extension_id,
-    const base::Value& attributes) {
-  bool has_malware_value = HasOmahaBlocklistStateInAttributes(
-      attributes, BitMapBlocklistState::BLOCKLISTED_MALWARE);
-  if (!has_malware_value) {
-    ReportNoUpdateCheckKeys();
-    if (!blocklist_prefs::HasOmahaBlocklistState(
-            extension_id, BitMapBlocklistState::BLOCKLISTED_MALWARE,
-            extension_prefs_)) {
-      return;
-    }
-    // The extension was previously blocklisted by Omaha, but is no longer.
-    // Clear the old omaha state.
-    ReportReenableExtension(ExtensionUpdateCheckDataKey::kMalware);
-    blocklist_prefs::RemoveOmahaBlocklistState(
-        extension_id, BitMapBlocklistState::BLOCKLISTED_MALWARE,
-        extension_prefs_);
-    extension_service_->OnBlocklistStateRemoved(extension_id);
-    return;
-  }
-
-  if (blocklist_prefs::HasOmahaBlocklistState(
-          extension_id, BitMapBlocklistState::BLOCKLISTED_MALWARE,
-          extension_prefs_)) {
-    // The extension is already disabled. No work needs to be done.
-    return;
-  }
-
-  ReportExtensionDisabledRemotely(
-      extension_service_->IsExtensionEnabled(extension_id),
-      ExtensionUpdateCheckDataKey::kMalware);
-
-  blocklist_prefs::AddOmahaBlocklistState(
-      extension_id, BitMapBlocklistState::BLOCKLISTED_MALWARE,
-      extension_prefs_);
-  extension_service_->OnBlocklistStateAdded(extension_id);
-}
-
-void OmahaAttributesHandler::HandleGreylistOmahaAttribute(
-    const ExtensionId& extension_id,
-    const base::Value& attributes,
-    const base::Feature& feature_flag,
-    BitMapBlocklistState greylist_state,
-    ExtensionUpdateCheckDataKey reason) {
-  bool has_attribute_value =
-      HasOmahaBlocklistStateInAttributes(attributes, greylist_state);
-  bool has_omaha_blocklist_state = blocklist_prefs::HasOmahaBlocklistState(
-      extension_id, greylist_state, extension_prefs_);
-  if (!base::FeatureList::IsEnabled(feature_flag) || !has_attribute_value) {
-    if (has_omaha_blocklist_state) {
-      blocklist_prefs::RemoveOmahaBlocklistState(extension_id, greylist_state,
-                                                 extension_prefs_);
-      ReportReenableExtension(reason);
-    }
-    extension_service_->OnGreylistStateRemoved(extension_id);
-    return;
-  }
-
-  ReportExtensionDisabledRemotely(
-      /*should_be_remotely_disabled=*/!has_omaha_blocklist_state, reason);
-  blocklist_prefs::AddOmahaBlocklistState(extension_id, greylist_state,
-                                          extension_prefs_);
-  extension_service_->OnGreylistStateAdded(extension_id, greylist_state);
-}
-
 }  // namespace extensions
--- a/chrome/browser/extensions/omaha_attributes_handler.h
+++ b/chrome/browser/extensions/omaha_attributes_handler.h
@@ -50,23 +50,6 @@ class OmahaAttributesHandler {
                                            const base::Value& attributes);
 
  private:
-  // Performs action based on `attributes` for the `extension_id`. If the
-  // extension does not have the _malware attribute, remove it from the Omaha
-  // malware blocklist state and maybe reload it. Otherwise, add it to the Omaha
-  // malware blocklist state and maybe unload it.
-  void HandleMalwareOmahaAttribute(const ExtensionId& extension_id,
-                                   const base::Value& attributes);
-  // Performs action based on `attributes` for the `extension_id`. If the
-  // extension is not in the `greylist_state` or the `feature_flag` is disabled,
-  // remove it from the Omaha blocklist state and maybe re-enable it. Otherwise,
-  // add it to the Omaha blocklist state and maybe disable it. `reason` is used
-  // for logging UMA metrics.
-  void HandleGreylistOmahaAttribute(const ExtensionId& extension_id,
-                                    const base::Value& attributes,
-                                    const base::Feature& feature_flag,
-                                    BitMapBlocklistState greylist_state,
-                                    ExtensionUpdateCheckDataKey reason);
-
   raw_ptr<ExtensionPrefs> extension_prefs_ = nullptr;
   raw_ptr<ExtensionService> extension_service_ = nullptr;
 };
--- a/chrome/browser/extensions/safe_browsing_verdict_handler.cc
+++ b/chrome/browser/extensions/safe_browsing_verdict_handler.cc
@@ -119,7 +119,6 @@ void SafeBrowsingVerdictHandler::UpdateB
     blocklist_.Remove(id);
     blocklist_prefs::SetSafeBrowsingExtensionBlocklistState(
         id, BitMapBlocklistState::NOT_BLOCKLISTED, extension_prefs_);
-    extension_service_->OnBlocklistStateRemoved(id);
     UMA_HISTOGRAM_ENUMERATION("ExtensionBlacklist.UnblacklistInstalled",
                               extension->location());
   }
@@ -133,7 +132,6 @@ void SafeBrowsingVerdictHandler::UpdateB
     blocklist_.Insert(extension);
     blocklist_prefs::SetSafeBrowsingExtensionBlocklistState(
         id, BitMapBlocklistState::BLOCKLISTED_MALWARE, extension_prefs_);
-    extension_service_->OnBlocklistStateAdded(id);
     UMA_HISTOGRAM_ENUMERATION("ExtensionBlacklist.BlacklistInstalled",
                               extension->location());
   }
@@ -157,7 +155,6 @@ void SafeBrowsingVerdictHandler::UpdateG
     blocklist_prefs::SetSafeBrowsingExtensionBlocklistState(
         extension->id(), BitMapBlocklistState::NOT_BLOCKLISTED,
         extension_prefs_);
-    extension_service_->OnGreylistStateRemoved(extension->id());
     UMA_HISTOGRAM_ENUMERATION("Extensions.Greylist.Enabled",
                               extension->location());
   }
@@ -177,7 +174,6 @@ void SafeBrowsingVerdictHandler::UpdateG
         blocklist_prefs::BlocklistStateToBitMapBlocklistState(greylist_state);
     blocklist_prefs::SetSafeBrowsingExtensionBlocklistState(
         extension->id(), bitmap_greylist_state, extension_prefs_);
-    extension_service_->OnGreylistStateAdded(id, bitmap_greylist_state);
     UMA_HISTOGRAM_ENUMERATION("Extensions.Greylist.Disabled",
                               extension->location());
   }
--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.cc
@@ -35,8 +35,6 @@
 #include "chrome/browser/file_system_access/file_system_access_permission_request_manager.h"
 #include "chrome/browser/installable/installable_utils.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/download_protection/download_protection_service.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/browser/ui/file_system_access_dialogs.h"
 #include "chrome/common/chrome_paths.h"
 #include "components/content_settings/core/browser/host_content_settings_map.h"
@@ -304,83 +302,6 @@ BindResultCallbackToCurrentSequence(
       base::SequencedTaskRunnerHandle::Get(), std::move(callback));
 }
 
-void DoSafeBrowsingCheckOnUIThread(
-    content::GlobalRenderFrameHostId frame_id,
-    std::unique_ptr<content::FileSystemAccessWriteItem> item,
-    safe_browsing::CheckDownloadCallback callback) {
-  DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
-  // Download Protection Service is not supported on Android.
-#if BUILDFLAG(FULL_SAFE_BROWSING)
-  safe_browsing::SafeBrowsingService* sb_service =
-      g_browser_process->safe_browsing_service();
-  if (!sb_service || !sb_service->download_protection_service() ||
-      !sb_service->download_protection_service()->enabled()) {
-    std::move(callback).Run(safe_browsing::DownloadCheckResult::UNKNOWN);
-    return;
-  }
-
-  if (!item->browser_context) {
-    content::RenderProcessHost* rph =
-        content::RenderProcessHost::FromID(frame_id.child_id);
-    if (!rph) {
-      std::move(callback).Run(safe_browsing::DownloadCheckResult::UNKNOWN);
-      return;
-    }
-    item->browser_context = rph->GetBrowserContext();
-  }
-
-  if (!item->web_contents) {
-    content::RenderFrameHost* rfh = content::RenderFrameHost::FromID(frame_id);
-    if (rfh) {
-      DCHECK_NE(rfh->GetLifecycleState(),
-                content::RenderFrameHost::LifecycleState::kPrerendering);
-      item->web_contents = content::WebContents::FromRenderFrameHost(rfh);
-    }
-  }
-
-  sb_service->download_protection_service()->CheckFileSystemAccessWrite(
-      std::move(item), std::move(callback));
-#endif
-}
-
-ChromeFileSystemAccessPermissionContext::AfterWriteCheckResult
-InterpretSafeBrowsingResult(safe_browsing::DownloadCheckResult result) {
-  using Result = safe_browsing::DownloadCheckResult;
-  switch (result) {
-    // Only allow downloads that are marked as SAFE or UNKNOWN by SafeBrowsing.
-    // All other types are going to be blocked. UNKNOWN could be the result of a
-    // failed safe browsing ping.
-    case Result::UNKNOWN:
-    case Result::SAFE:
-    case Result::ALLOWLISTED_BY_POLICY:
-      return ChromeFileSystemAccessPermissionContext::AfterWriteCheckResult::
-          kAllow;
-
-    case Result::DANGEROUS:
-    case Result::UNCOMMON:
-    case Result::DANGEROUS_HOST:
-    case Result::POTENTIALLY_UNWANTED:
-    case Result::BLOCKED_PASSWORD_PROTECTED:
-    case Result::BLOCKED_TOO_LARGE:
-    case Result::BLOCKED_UNSUPPORTED_FILE_TYPE:
-    case Result::DANGEROUS_ACCOUNT_COMPROMISE:
-      return ChromeFileSystemAccessPermissionContext::AfterWriteCheckResult::
-          kBlock;
-
-    // This shouldn't be returned for File System Access write checks.
-    case Result::ASYNC_SCANNING:
-    case Result::SENSITIVE_CONTENT_WARNING:
-    case Result::SENSITIVE_CONTENT_BLOCK:
-    case Result::DEEP_SCANNED_SAFE:
-    case Result::PROMPT_FOR_SCANNING:
-      NOTREACHED();
-      return ChromeFileSystemAccessPermissionContext::AfterWriteCheckResult::
-          kAllow;
-  }
-  NOTREACHED();
-  return ChromeFileSystemAccessPermissionContext::AfterWriteCheckResult::kBlock;
-}
-
 std::string GenerateLastPickedDirectoryKey(const std::string& id) {
   return id.empty() ? kDefaultLastPickedDirectoryKey
                     : base::StrCat({kCustomLastPickedDirectoryKey, "-", id});
@@ -1133,28 +1054,6 @@ void ChromeFileSystemAccessPermissionCon
                      std::move(callback)));
 }
 
-void ChromeFileSystemAccessPermissionContext::PerformAfterWriteChecks(
-    std::unique_ptr<content::FileSystemAccessWriteItem> item,
-    content::GlobalRenderFrameHostId frame_id,
-    base::OnceCallback<void(AfterWriteCheckResult)> callback) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-  content::GetUIThreadTaskRunner({})->PostTask(
-      FROM_HERE,
-      base::BindOnce(
-          &DoSafeBrowsingCheckOnUIThread, frame_id, std::move(item),
-          base::BindOnce(
-              [](scoped_refptr<base::TaskRunner> task_runner,
-                 base::OnceCallback<void(AfterWriteCheckResult result)>
-                     callback,
-                 safe_browsing::DownloadCheckResult result) {
-                task_runner->PostTask(
-                    FROM_HERE,
-                    base::BindOnce(std::move(callback),
-                                   InterpretSafeBrowsingResult(result)));
-              },
-              base::SequencedTaskRunnerHandle::Get(), std::move(callback))));
-}
-
 void ChromeFileSystemAccessPermissionContext::
     DidConfirmSensitiveDirectoryAccess(
         const url::Origin& origin,
--- a/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
+++ b/chrome/browser/file_system_access/chrome_file_system_access_permission_context.h
@@ -86,10 +86,6 @@ class ChromeFileSystemAccessPermissionCo
       HandleType handle_type,
       content::GlobalRenderFrameHostId frame_id,
       base::OnceCallback<void(SensitiveDirectoryResult)> callback) override;
-  void PerformAfterWriteChecks(
-      std::unique_ptr<content::FileSystemAccessWriteItem> item,
-      content::GlobalRenderFrameHostId frame_id,
-      base::OnceCallback<void(AfterWriteCheckResult)> callback) override;
   bool CanObtainReadPermission(const url::Origin& origin) override;
   bool CanObtainWritePermission(const url::Origin& origin) override;
 
--- a/chrome/browser/media/webrtc/display_media_access_handler.cc
+++ b/chrome/browser/media/webrtc/display_media_access_handler.cc
@@ -24,6 +24,7 @@
 #include "chrome/browser/safe_browsing/user_interaction_observer.h"
 #include "chrome/common/pref_names.h"
 #include "components/prefs/pref_service.h"
+#include "components/safe_browsing/buildflags.h"
 #include "components/url_formatter/elide_url.h"
 #include "content/public/browser/browser_thread.h"
 #include "content/public/browser/desktop_capture.h"
@@ -106,6 +107,7 @@ void DisplayMediaAccessHandler::HandleRe
     return;
   }
 
+  #if BUILDFLAG(FULL_SAFE_BROWSING)
   // SafeBrowsing Delayed Warnings experiment can delay some SafeBrowsing
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Show the warning
@@ -120,6 +122,7 @@ void DisplayMediaAccessHandler::HandleRe
     observer->OnDesktopCaptureRequest();
     return;
   }
+  #endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
 #if defined(OS_MAC)
   // Do not allow picker UI to be shown on a page that isn't in the foreground
--- a/chrome/browser/new_tab_page/modules/safe_browsing/safe_browsing_handler.cc
+++ b/chrome/browser/new_tab_page/modules/safe_browsing/safe_browsing_handler.cc
@@ -13,10 +13,8 @@
 #include "components/prefs/pref_service.h"
 #include "components/safe_browsing/core/browser/safe_browsing_metrics_collector.h"
 #include "components/safe_browsing/core/common/safe_browsing_policy_handler.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 #include "components/search/ntp_features.h"
 
-using ::safe_browsing::IsEnhancedProtectionEnabled;
 using ::safe_browsing::SafeBrowsingMetricsCollectorFactory;
 using ::safe_browsing::SafeBrowsingPolicyHandler;
 
@@ -66,7 +64,7 @@ void SafeBrowsingHandler::CanShowModule(
   bool managed =
       SafeBrowsingPolicyHandler::IsSafeBrowsingProtectionLevelSetByPolicy(
           pref_service_);
-  bool already_enabled = IsEnhancedProtectionEnabled(*pref_service_);
+  bool already_enabled = false;
   bool module_already_opened =
       pref_service_->GetBoolean(prefs::kSafeBrowsingModuleOpened);
   base::Time cooldown_end = GetLastCooldownEndTime(pref_service_);
--- a/chrome/browser/notifications/notification_display_service_impl.cc
+++ b/chrome/browser/notifications/notification_display_service_impl.cc
@@ -17,7 +17,6 @@
 #include "chrome/browser/notifications/notification_display_service_factory.h"
 #include "chrome/browser/notifications/persistent_notification_handler.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/tailored_security/consented_notification_desktop.h"
 #include "chrome/browser/updates/announcement_notification/announcement_notification_handler.h"
 #include "chrome/common/pref_names.h"
 #include "components/pref_registry/pref_registry_syncable.h"
@@ -88,14 +87,6 @@ NotificationDisplayServiceImpl::Notifica
             profile_));
 #endif
 
-#if defined(OS_LINUX) || defined(OS_CHROMEOS) || defined(OS_MAC) || \
-    defined(OS_WIN)
-    AddNotificationHandler(
-        NotificationHandler::Type::TAILORED_SECURITY_CONSENTED,
-        std::make_unique<
-            safe_browsing::TailoredSecurityConsentedNotificationHandler>());
-#endif
-
 #if BUILDFLAG(ENABLE_EXTENSIONS)
     AddNotificationHandler(
         NotificationHandler::Type::EXTENSION,
--- a/chrome/browser/password_manager/chrome_password_manager_client.cc
+++ b/chrome/browser/password_manager/chrome_password_manager_client.cc
@@ -35,7 +35,6 @@
 #include "chrome/browser/password_manager/password_scripts_fetcher_factory.h"
 #include "chrome/browser/password_manager/password_store_factory.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/chrome_password_protection_service.h"
 #include "chrome/browser/safe_browsing/user_interaction_observer.h"
 #include "chrome/browser/signin/identity_manager_factory.h"
 #include "chrome/browser/sync/sync_service_factory.h"
@@ -112,11 +111,11 @@
 #if BUILDFLAG(FULL_SAFE_BROWSING)
 #include "chrome/browser/safe_browsing/advanced_protection_status_manager.h"
 #include "chrome/browser/safe_browsing/advanced_protection_status_manager_factory.h"
+#endif
 #include "third_party/blink/public/mojom/clipboard/clipboard.mojom.h"
 #include "ui/base/clipboard/clipboard.h"
 #include "ui/base/data_transfer_policy/data_transfer_endpoint.h"
 #include "ui/events/keycodes/keyboard_codes.h"
-#endif
 
 #if defined(OS_ANDROID)
 #include "chrome/browser/android/tab_android.h"
@@ -828,6 +827,7 @@ autofill::LanguageCode ChromePasswordMan
   return autofill::LanguageCode();
 }
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 safe_browsing::PasswordProtectionService*
 ChromePasswordManagerClient::GetPasswordProtectionService() const {
   return safe_browsing::ChromePasswordProtectionService::
@@ -838,13 +838,6 @@ ChromePasswordManagerClient::GetPassword
 void ChromePasswordManagerClient::CheckSafeBrowsingReputation(
     const GURL& form_action,
     const GURL& frame_url) {
-  safe_browsing::PasswordProtectionService* pps =
-      GetPasswordProtectionService();
-  if (pps) {
-    pps->MaybeStartPasswordFieldOnFocusRequest(
-        web_contents(), web_contents()->GetLastCommittedURL(), form_action,
-        frame_url, pps->GetAccountInfo().hosted_domain);
-  }
 }
 #endif  // defined(ON_FOCUS_PING_ENABLED)
 
@@ -854,22 +847,10 @@ void ChromePasswordManagerClient::CheckP
     const std::vector<password_manager::MatchingReusedCredential>&
         matching_reused_credentials,
     bool password_field_exists) {
-  safe_browsing::PasswordProtectionService* pps =
-      GetPasswordProtectionService();
-  if (!pps)
-    return;
-
-  pps->MaybeStartProtectedPasswordEntryRequest(
-      web_contents(), web_contents()->GetLastCommittedURL(), username,
-      password_type, matching_reused_credentials, password_field_exists);
 }
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
 void ChromePasswordManagerClient::LogPasswordReuseDetectedEvent() {
-  safe_browsing::PasswordProtectionService* pps =
-      GetPasswordProtectionService();
-  if (pps) {
-    pps->MaybeLogPasswordReuseDetectedEvent(web_contents());
-  }
 }
 
 #if !defined(OS_ANDROID)
@@ -1373,9 +1354,11 @@ void ChromePasswordManagerClient::OnPast
   }
 
   was_on_paste_called_ = true;
+#if defined(SYNC_PASSWORD_REUSE_WARNING_ENABLED)
   password_reuse_detection_manager_.OnPaste(std::move(text));
+#endif // defined(SYNC_PASSWORD_REUSE_WARNING_ENABLED)
 }
-#endif
+#endif //  !defined(OS_ANDROID)
 
 void ChromePasswordManagerClient::RenderFrameCreated(
     content::RenderFrameHost* render_frame_host) {
@@ -1410,7 +1393,9 @@ void ChromePasswordManagerClient::OnInpu
   if (key_event.windows_key_code == (ui::VKEY_V & 0x1f)) {
     OnPaste();
   } else {
+#if defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)
     password_reuse_detection_manager_.OnKeyPressedCommitted(key_event.text);
+#endif  // defined(SYNC_PASSWORD_REUSE_DETECTION_ENABLED)
   }
 #endif  // defined(OS_ANDROID)
 }
@@ -1449,6 +1434,7 @@ bool ChromePasswordManagerClient::IsPass
     is_enabled = false;
   }
 
+  #if BUILDFLAG(FULL_SAFE_BROWSING)
   // SafeBrowsing Delayed Warnings experiment can delay some SafeBrowsing
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Disable password
@@ -1459,6 +1445,7 @@ bool ChromePasswordManagerClient::IsPass
     observer->OnPasswordSaveOrAutofillDenied();
     is_enabled = false;
   }
+  #endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
   if (log_manager_->IsLoggingActive()) {
     password_manager::BrowserSavePasswordProgressLogger logger(
--- a/chrome/browser/password_manager/chrome_password_manager_client.h
+++ b/chrome/browser/password_manager/chrome_password_manager_client.h
@@ -204,13 +204,14 @@ class ChromePasswordManagerClient
   void AnnotateNavigationEntry(bool has_password_field) override;
   autofill::LanguageCode GetPageLanguage() const override;
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   safe_browsing::PasswordProtectionService* GetPasswordProtectionService()
       const override;
 
 #if defined(ON_FOCUS_PING_ENABLED)
   void CheckSafeBrowsingReputation(const GURL& form_action,
                                    const GURL& frame_url) override;
-#endif
+#endif // defined(ON_FOCUS_PING_ENABLED)
 
   void CheckProtectedPasswordEntry(
       password_manager::metrics_util::PasswordType reused_password_type,
@@ -218,6 +219,7 @@ class ChromePasswordManagerClient
       const std::vector<password_manager::MatchingReusedCredential>&
           matching_reused_credentials,
       bool password_field_exists) override;
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
   void LogPasswordReuseDetectedEvent() override;
 
--- a/chrome/browser/permissions/abusive_origin_permission_revocation_request.cc
+++ b/chrome/browser/permissions/abusive_origin_permission_revocation_request.cc
@@ -17,7 +17,6 @@
 #include "components/permissions/permissions_client.h"
 #include "components/prefs/pref_service.h"
 #include "components/safe_browsing/core/browser/db/database_manager.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 
 namespace {
 constexpr char kExcludedKey[] = "exempted";
@@ -136,6 +135,7 @@ void AbusiveOriginPermissionRevocationRe
   DCHECK(profile_);
   DCHECK(callback_);
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (!AbusiveOriginNotificationsPermissionRevocationConfig::IsEnabled() ||
       !safe_browsing::IsSafeBrowsingEnabled(*profile_->GetPrefs()) ||
       IsOriginExemptedFromFutureRevocations(profile_, origin_)) {
@@ -182,6 +182,7 @@ void AbusiveOriginPermissionRevocationRe
     }
   }
   NotifyCallback(Outcome::PERMISSION_NOT_REVOKED);
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 }
 
 void AbusiveOriginPermissionRevocationRequest::OnSafeBrowsingVerdictReceived(
--- a/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc
+++ b/chrome/browser/permissions/contextual_notification_permission_ui_selector.cc
@@ -17,7 +17,6 @@
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/permissions/quiet_notification_permission_ui_config.h"
 #include "chrome/browser/permissions/quiet_notification_permission_ui_state.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/common/chrome_features.h"
 #include "components/permissions/permission_request.h"
 #include "components/permissions/request_type.h"
@@ -151,9 +150,6 @@ void ContextualNotificationPermissionUiS
 }
 
 void ContextualNotificationPermissionUiSelector::Cancel() {
-  // The computation either finishes synchronously above, or is waiting on the
-  // Safe Browsing check.
-  safe_browsing_request_.reset();
 }
 
 bool ContextualNotificationPermissionUiSelector::IsPermissionRequestSupported(
@@ -179,24 +175,14 @@ void ContextualNotificationPermissionUiS
   absl::optional<Decision> decision =
       GetDecisionBasedOnSiteReputation(reputation);
 
-  // If the PreloadData suggests this is an unacceptable site, ping Safe
-  // Browsing to verify; but do not ping if it is not warranted.
+  // If the PreloadData suggests this is an unacceptable site, assume it is
+  // correct, since we can't access safe browsing.
   if (!decision || (!decision->quiet_ui_reason && !decision->warning_reason)) {
     Notify(Decision::UseNormalUiAndShowNoWarning());
-    return;
+  } else {
+    // decision has a value, unwrap with .value()
+    Notify(decision.value());
   }
-
-  DCHECK(!safe_browsing_request_);
-  DCHECK(g_browser_process->safe_browsing_service());
-
-  // It is fine to use base::Unretained() here, as |safe_browsing_request_|
-  // guarantees not to fire the callback after its destruction.
-  safe_browsing_request_.emplace(
-      g_browser_process->safe_browsing_service()->database_manager(),
-      base::DefaultClock::GetInstance(), origin,
-      base::BindOnce(&ContextualNotificationPermissionUiSelector::
-                         OnSafeBrowsingVerdictReceived,
-                     base::Unretained(this), *decision));
 }
 
 void ContextualNotificationPermissionUiSelector::OnSafeBrowsingVerdictReceived(
--- a/chrome/browser/permissions/prediction_based_permission_ui_selector.cc
+++ b/chrome/browser/permissions/prediction_based_permission_ui_selector.cc
@@ -23,7 +23,6 @@
 #include "components/permissions/prediction_service/prediction_service.h"
 #include "components/permissions/prediction_service/prediction_service_messages.pb.h"
 #include "components/prefs/pref_service.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 
 namespace {
 
@@ -212,10 +211,8 @@ bool PredictionBasedPermissionUiSelector
     permissions::RequestType request_type) {
   // We need to also check `kQuietNotificationPrompts` here since there is no
   // generic safeguard anywhere else in the stack.
-  if (!base::FeatureList::IsEnabled(features::kQuietNotificationPrompts) ||
-      !safe_browsing::IsSafeBrowsingEnabled(*(profile_->GetPrefs()))) {
+  if (!base::FeatureList::IsEnabled(features::kQuietNotificationPrompts))
     return false;
-  }
   double hold_back_chance = 0.0;
   bool is_permissions_predictions_enabled = false;
   switch (request_type) {
--- a/chrome/browser/reputation/reputation_service.cc
+++ b/chrome/browser/reputation/reputation_service.cc
@@ -119,9 +119,7 @@ void ReputationService::GetReputationSta
                                             ReputationCheckCallback callback) {
   DCHECK(url.SchemeIsHTTPOrHTTPS());
 
-  bool has_delayed_warning =
-      !!safe_browsing::SafeBrowsingUserInteractionObserver::FromWebContents(
-          web_contents);
+  bool has_delayed_warning = false;
 
   LookalikeUrlService* service = LookalikeUrlService::Get(profile_);
   if (service->EngagedSitesNeedUpdating()) {
--- a/chrome/browser/safe_browsing/metrics/safe_browsing_metrics_provider.cc
+++ b/chrome/browser/safe_browsing/metrics/safe_browsing_metrics_provider.cc
@@ -7,7 +7,6 @@
 #include "base/metrics/histogram_functions.h"
 #include "chrome/browser/profiles/profile.h"
 #include "components/prefs/pref_service.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 
 namespace safe_browsing {
 
@@ -17,15 +16,6 @@ SafeBrowsingMetricsProvider::~SafeBrowsi
 
 void SafeBrowsingMetricsProvider::ProvideCurrentSessionData(
     metrics::ChromeUserMetricsExtension* uma_proto) {
-  Profile* profile = cached_profile_.GetMetricsProfile();
-
-  if (!profile)
-    return;
-
-  SafeBrowsingState state = GetSafeBrowsingState(*profile->GetPrefs());
-
-  base::UmaHistogramEnumeration(
-      "SafeBrowsing.Pref.MainProfile.SafeBrowsingState", state);
 }
 
 }  // namespace safe_browsing
--- a/chrome/browser/safe_browsing/url_lookup_service_factory.cc
+++ b/chrome/browser/safe_browsing/url_lookup_service_factory.cc
@@ -59,28 +59,7 @@ RealTimeUrlLookupServiceFactory::RealTim
 
 KeyedService* RealTimeUrlLookupServiceFactory::BuildServiceInstanceFor(
     content::BrowserContext* context) const {
-  if (!g_browser_process->safe_browsing_service()) {
-    return nullptr;
-  }
-  Profile* profile = Profile::FromBrowserContext(context);
-  auto url_loader_factory =
-      std::make_unique<network::CrossThreadPendingSharedURLLoaderFactory>(
-          g_browser_process->safe_browsing_service()->GetURLLoaderFactory(
-              profile));
-  return new RealTimeUrlLookupService(
-      network::SharedURLLoaderFactory::Create(std::move(url_loader_factory)),
-      VerdictCacheManagerFactory::GetForProfile(profile),
-      base::BindRepeating(&safe_browsing::GetUserPopulationForProfile, profile),
-      profile->GetPrefs(),
-      std::make_unique<SafeBrowsingPrimaryAccountTokenFetcher>(
-          IdentityManagerFactory::GetForProfile(profile)),
-      base::BindRepeating(&safe_browsing::SyncUtils::
-                              AreSigninAndSyncSetUpForSafeBrowsingTokenFetches,
-                          SyncServiceFactory::GetForProfile(profile),
-                          IdentityManagerFactory::GetForProfile(profile)),
-      profile->IsOffTheRecord(), g_browser_process->variations_service(),
-      SafeBrowsingNavigationObserverManagerFactory::GetForBrowserContext(
-          profile));
+  return nullptr;
 }
 
 }  // namespace safe_browsing
--- a/chrome/browser/ssl/chrome_security_blocking_page_factory.cc
+++ b/chrome/browser/ssl/chrome_security_blocking_page_factory.cc
@@ -142,15 +142,6 @@ CreateSettingsPageHelper() {
       CreateChromeSettingsPageHelper();
 }
 
-void LogSafeBrowsingSecuritySensitiveAction(
-    safe_browsing::SafeBrowsingMetricsCollector* metrics_collector) {
-  if (metrics_collector) {
-    metrics_collector->AddSafeBrowsingEventToPref(
-        safe_browsing::SafeBrowsingMetricsCollector::EventType::
-            SECURITY_SENSITIVE_SSL_INTERSTITIAL);
-  }
-}
-
 }  // namespace
 
 std::unique_ptr<SSLBlockingPage>
@@ -174,10 +165,6 @@ ChromeSecurityBlockingPageFactory::Creat
           Profile::FromBrowserContext(web_contents->GetBrowserContext()));
   state->DidDisplayErrorPage(cert_error);
 
-  LogSafeBrowsingSecuritySensitiveAction(
-      safe_browsing::SafeBrowsingMetricsCollectorFactory::GetForProfile(
-          Profile::FromBrowserContext(web_contents->GetBrowserContext())));
-
   auto controller_client = std::make_unique<SSLErrorControllerClient>(
       web_contents, ssl_info, cert_error, request_url,
       std::move(metrics_helper), CreateSettingsPageHelper());
@@ -247,10 +234,6 @@ ChromeSecurityBlockingPageFactory::Creat
     std::unique_ptr<SSLCertReporter> ssl_cert_reporter,
     const net::SSLInfo& ssl_info,
     const std::string& mitm_software_name) {
-  LogSafeBrowsingSecuritySensitiveAction(
-      safe_browsing::SafeBrowsingMetricsCollectorFactory::GetForProfile(
-          Profile::FromBrowserContext(web_contents->GetBrowserContext())));
-
   auto page = std::make_unique<MITMSoftwareBlockingPage>(
       web_contents, cert_error, request_url, std::move(ssl_cert_reporter),
       /*can_show_enhanced_protection_message=*/true, ssl_info,
@@ -272,10 +255,6 @@ ChromeSecurityBlockingPageFactory::Creat
     const GURL& request_url,
     std::unique_ptr<SSLCertReporter> ssl_cert_reporter,
     const net::SSLInfo& ssl_info) {
-  LogSafeBrowsingSecuritySensitiveAction(
-      safe_browsing::SafeBrowsingMetricsCollectorFactory::GetForProfile(
-          Profile::FromBrowserContext(web_contents->GetBrowserContext())));
-
   auto page = std::make_unique<BlockedInterceptionBlockingPage>(
       web_contents, cert_error, request_url, std::move(ssl_cert_reporter),
       /*can_show_enhanced_protection_message=*/true, ssl_info,
--- a/chrome/browser/ssl/sct_reporting_service_factory.cc
+++ b/chrome/browser/ssl/sct_reporting_service_factory.cc
@@ -32,15 +32,7 @@ SCTReportingServiceFactory::~SCTReportin
 
 KeyedService* SCTReportingServiceFactory::BuildServiceInstanceFor(
     content::BrowserContext* profile) const {
-  safe_browsing::SafeBrowsingService* safe_browsing_service =
-      g_browser_process->safe_browsing_service();
-  // In unit tests the safe browsing service can be null, if this happens,
-  // return null instead of crashing.
-  if (!safe_browsing_service)
-    return nullptr;
-
-  return new SCTReportingService(safe_browsing_service,
-                                 static_cast<Profile*>(profile));
+  return nullptr;
 }
 
 content::BrowserContext* SCTReportingServiceFactory::GetBrowserContextToUse(
--- a/chrome/browser/subresource_filter/chrome_content_subresource_filter_web_contents_helper_factory.cc
+++ b/chrome/browser/subresource_filter/chrome_content_subresource_filter_web_contents_helper_factory.cc
@@ -6,7 +6,6 @@
 
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/profiles/profile.h"
-#include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/browser/subresource_filter/subresource_filter_profile_context_factory.h"
 #include "components/safe_browsing/core/browser/db/database_manager.h"
 #include "components/subresource_filter/content/browser/content_subresource_filter_web_contents_helper.h"
@@ -18,10 +17,7 @@ namespace {
 // available. Otherwise returns nullptr.
 const scoped_refptr<safe_browsing::SafeBrowsingDatabaseManager>
 GetDatabaseManagerFromSafeBrowsingService() {
-  safe_browsing::SafeBrowsingService* safe_browsing_service =
-      g_browser_process->safe_browsing_service();
-  return safe_browsing_service ? safe_browsing_service->database_manager()
-                               : nullptr;
+  return nullptr;
 }
 
 }  // namespace
--- a/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc
+++ b/chrome/browser/ui/javascript_dialogs/javascript_tab_modal_dialog_manager_delegate_desktop.cc
@@ -16,6 +16,7 @@
 #include "components/javascript_dialogs/tab_modal_dialog_manager.h"
 #include "components/javascript_dialogs/tab_modal_dialog_view.h"
 #include "components/navigation_metrics/navigation_metrics.h"
+#include "components/safe_browsing/buildflags.h"
 #include "components/ukm/content/source_url_recorder.h"
 #include "content/public/browser/devtools_agent_host.h"
 #include "content/public/browser/navigation_handle.h"
@@ -36,6 +37,7 @@ JavaScriptTabModalDialogManagerDelegateD
 
 void JavaScriptTabModalDialogManagerDelegateDesktop::WillRunDialog() {
   BrowserList::AddObserver(this);
+  #if BUILDFLAG(FULL_SAFE_BROWSING)
   // SafeBrowsing Delayed Warnings experiment can delay some SafeBrowsing
   // warnings until user interaction. If the current page has a delayed warning,
   // it'll have a user interaction observer attached. Show the warning
@@ -46,6 +48,7 @@ void JavaScriptTabModalDialogManagerDele
   if (observer) {
     observer->OnJavaScriptDialog();
   }
+  #endif // BUILDFLAG(FULL_SAFE_BROWSING)
 }
 
 void JavaScriptTabModalDialogManagerDelegateDesktop::DidCloseDialog() {
--- a/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
+++ b/chrome/browser/ui/tab_contents/chrome_web_contents_view_handle_drop.cc
@@ -11,7 +11,10 @@
 #include "base/task/post_task.h"
 #include "base/task/task_runner_util.h"
 #include "base/task/thread_pool.h"
+#include "components/safe_browsing/buildflags.h"
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 #include "chrome/browser/enterprise/connectors/analysis/content_analysis_delegate.h"
+#endif
 #include "chrome/browser/profiles/profile.h"
 #include "chrome/browser/safe_browsing/cloud_content_scanning/deep_scanning_utils.h"
 #include "content/public/browser/web_contents.h"
@@ -22,6 +25,7 @@
 
 namespace {
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
 void CompletionCallback(
     content::WebContentsViewDelegate::DropCompletionCallback callback,
     const enterprise_connectors::ContentAnalysisDelegate::Data& data,
@@ -63,6 +67,7 @@ enterprise_connectors::ContentAnalysisDe
   }
   return data;
 }
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
 // Helper class to handle WebContents being destroyed while files are opened in
 // the threadpool. This class deletes itself either when it's no longer needed
@@ -76,6 +81,7 @@ class HandleDropScanData : public conten
       : content::WebContentsObserver(web_contents),
         callback_(std::move(callback)) {}
 
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   void ScanData(
       enterprise_connectors::ContentAnalysisDelegate::Data analysis_data) {
     DCHECK(web_contents());
@@ -87,6 +93,7 @@ class HandleDropScanData : public conten
 
     delete this;
   }
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 
   void WebContentsDestroyed() override { delete this; }
 
@@ -106,13 +113,16 @@ void HandleOnPerformDrop(
     content::WebContents* web_contents,
     const content::DropData& drop_data,
     content::WebContentsViewDelegate::DropCompletionCallback callback) {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   enterprise_connectors::ContentAnalysisDelegate::Data data;
+#endif
   Profile* profile =
       Profile::FromBrowserContext(web_contents->GetBrowserContext());
   auto connector =
       drop_data.filenames.empty()
           ? enterprise_connectors::AnalysisConnector::BULK_DATA_ENTRY
           : enterprise_connectors::AnalysisConnector::FILE_ATTACHED;
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   if (!enterprise_connectors::ContentAnalysisDelegate::IsEnabled(
           profile, web_contents->GetLastCommittedURL(), &data, connector)) {
     std::move(callback).Run(
@@ -152,4 +162,8 @@ void HandleOnPerformDrop(
     std::move(callback).Run(
         content::WebContentsViewDelegate::DropCompletionResult::kContinue);
   }
+#else
+  std::move(callback).Run(
+      content::WebContentsViewDelegate::DropCompletionResult::kContinue);
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
 }
--- a/chrome/browser/ui/views/download/download_item_view.cc
+++ b/chrome/browser/ui/views/download/download_item_view.cc
@@ -838,9 +838,7 @@ void DownloadItemView::UpdateLabels() {
   deep_scanning_label_->SetVisible(mode_ ==
                                    download::DownloadItemMode::kDeepScanning);
   if (deep_scanning_label_->GetVisible()) {
-    const int id = (model_->download() &&
-                    safe_browsing::DeepScanningRequest::ShouldUploadBinary(
-                        model_->download()))
+    const int id = model_->download()
                        ? IDS_PROMPT_DEEP_SCANNING_DOWNLOAD
                        : IDS_PROMPT_DEEP_SCANNING_APP_DOWNLOAD;
     const std::u16string filename = ElidedFilename(*deep_scanning_label_);
@@ -887,11 +885,15 @@ void DownloadItemView::UpdateButtons() {
   }
 
   const bool allow_open_during_deep_scan =
+#if BUILDFLAG(FULL_SAFE_BROWSING)
       (mode_ == download::DownloadItemMode::kDeepScanning) &&
       !enterprise_connectors::ConnectorsServiceFactory::GetForBrowserContext(
            model_->profile())
            ->DelayUntilVerdict(
                enterprise_connectors::AnalysisConnector::FILE_DOWNLOADED);
+#else
+      false;
+#endif // BUILDFLAG(FULL_SAFE_BROWSING)
   open_button_->SetEnabled((mode_ == download::DownloadItemMode::kNormal) ||
                            prompt_to_scan || allow_open_during_deep_scan);
 
@@ -1428,7 +1430,9 @@ void DownloadItemView::ShowContextMenuIm
 }
 
 void DownloadItemView::OpenDownloadDuringAsyncScanning() {
+#if BUILDFLAG(FULL_SAFE_BROWSING)
   model_->CompleteSafeBrowsingScan();
+#endif
   model_->SetOpenWhenComplete(true);
 }
 
--- a/chrome/browser/ui/views/safe_browsing/tailored_security_unconsented_modal.cc
+++ b/chrome/browser/ui/views/safe_browsing/tailored_security_unconsented_modal.cc
@@ -11,7 +11,6 @@
 #include "chrome/browser/ui/chrome_pages.h"
 #include "chrome/grit/generated_resources.h"
 #include "components/constrained_window/constrained_window_views.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 #include "content/public/browser/web_contents.h"
 #include "ui/base/l10n/l10n_util.h"
 #include "ui/base/metadata/metadata_impl_macros.h"
@@ -28,15 +27,6 @@ void RecordModalOutcomeAndRunCallback(Ta
 }
 
 void EnableEsbAndShowSettings(content::WebContents* web_contents) {
-  Profile* profile =
-      Profile::FromBrowserContext(web_contents->GetBrowserContext());
-  SetSafeBrowsingState(profile->GetPrefs(),
-                       SafeBrowsingState::ENHANCED_PROTECTION,
-                       /*is_esb_enabled_in_sync=*/false);
-  if (!chrome::FindBrowserWithWebContents(web_contents))
-    return;
-  chrome::ShowSafeBrowsingEnhancedProtection(
-      chrome::FindBrowserWithWebContents(web_contents));
 }
 
 }  // namespace
--- a/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
+++ b/chrome/browser/ui/webui/downloads/downloads_dom_handler.cc
@@ -367,7 +367,6 @@ void DownloadsDOMHandler::OpenDuringScan
   if (download) {
     DownloadItemModel model(download);
     model.SetOpenWhenComplete(true);
-    model.CompleteSafeBrowsingScan();
   }
 }
 
--- a/chrome/browser/ui/webui/management/management_ui_handler.cc
+++ b/chrome/browser/ui/webui/management/management_ui_handler.cc
@@ -805,12 +805,6 @@ base::Value ManagementUIHandler::GetThre
                                   &info);
   }
 
-  if (connectors_service->GetAppliedRealTimeUrlCheck() !=
-      safe_browsing::REAL_TIME_CHECK_DISABLED) {
-    AddThreatProtectionPermission(kManagementOnPageVisitedEvent,
-                                  kManagementOnPageVisitedVisibleData, &info);
-  }
-
   const std::string enterprise_manager =
       connectors_service->GetManagementDomain();
 
--- a/chrome/browser/webshare/share_service_impl.cc
+++ b/chrome/browser/webshare/share_service_impl.cc
@@ -15,7 +15,9 @@
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/safe_browsing/safe_browsing_service.h"
 #include "chrome/common/chrome_features.h"
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 #include "components/safe_browsing/content/common/file_type_policies.h"
+#endif
 #include "components/safe_browsing/core/browser/db/database_manager.h"
 #include "content/public/browser/web_contents.h"
 #include "mojo/public/cpp/bindings/self_owned_receiver.h"
@@ -195,11 +197,13 @@ void ShareServiceImpl::Share(const std::
     // Check if at least one file is marked by the download protection service
     // to send a ping to check this file type.
     const base::FilePath path = base::FilePath::FromUTF8Unsafe(file->name);
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
     if (!should_check_url &&
         safe_browsing::FileTypePolicies::GetInstance()->IsCheckedBinaryFile(
             path)) {
       should_check_url = true;
     }
+#endif // BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 
     // In the case where the original blob handle was to a native file (of
     // unknown size), the serialized data does not contain an accurate file
@@ -209,6 +213,7 @@ void ShareServiceImpl::Share(const std::
   }
 
   DCHECK(!safe_browsing_request_);
+#if BUILDFLAG(SAFE_BROWSING_AVAILABLE)
   if (should_check_url && g_browser_process->safe_browsing_service()) {
     safe_browsing_request_.emplace(
         g_browser_process->safe_browsing_service()->database_manager(),
@@ -218,6 +223,7 @@ void ShareServiceImpl::Share(const std::
                        std::move(files), std::move(callback)));
     return;
   }
+#endif // BUILDFLAG(SAFE_BROWSING_AVAILABLE)
 
   OnSafeBrowsingResultReceived(title, text, share_url, std::move(files),
                                std::move(callback),
--- a/components/password_manager/content/browser/content_password_manager_driver.cc
+++ b/components/password_manager/content/browser/content_password_manager_driver.cc
@@ -407,7 +407,7 @@ void ContentPasswordManagerDriver::Check
   if (client_->GetMetricsRecorder()) {
     client_->GetMetricsRecorder()->RecordUserFocusedPasswordField();
   }
-#if defined(ON_FOCUS_PING_ENABLED)
+#if defined(ON_FOCUS_PING_ENABLED) && BUILDFLAG(FULL_SAFE_BROWSING)
   client_->CheckSafeBrowsingReputation(form_action, frame_url);
 #endif
 }
--- a/components/password_manager/core/browser/password_manager_client.h
+++ b/components/password_manager/core/browser/password_manager_client.h
@@ -340,11 +340,14 @@ class PasswordManagerClient {
   // Returns the current best guess as to the page's display language.
   virtual autofill::LanguageCode GetPageLanguage() const;
 
+#if (defined(ON_FOCUS_PING_ENABLED) || defined(PASSWORD_REUSE_DETECTION_ENABLED)) && \
+    BUILDFLAG(FULL_SAFE_BROWSING)
   // Return the PasswordProtectionService associated with this instance.
   virtual safe_browsing::PasswordProtectionService*
   GetPasswordProtectionService() const = 0;
+#endif
 
-#if defined(ON_FOCUS_PING_ENABLED)
+#if defined(ON_FOCUS_PING_ENABLED) && BUILDFLAG(FULL_SAFE_BROWSING)
   // Checks the safe browsing reputation of the webpage when the
   // user focuses on a username/password field. This is used for reporting
   // only, and won't trigger a warning.
@@ -352,6 +355,7 @@ class PasswordManagerClient {
                                            const GURL& frame_url) = 0;
 #endif
 
+#if defined(PASSWORD_REUSE_DETECTION_ENABLED)
   // Checks the safe browsing reputation of the webpage where password reuse
   // happens. This is called by the PasswordReuseDetectionManager when a
   // protected password is typed on the wrong domain. This may trigger a
@@ -364,6 +368,7 @@ class PasswordManagerClient {
       const std::string& username,
       const std::vector<MatchingReusedCredential>& matching_reused_credentials,
       bool password_field_exists) = 0;
+#endif
 
   // Records a Chrome Sync event that GAIA password reuse was detected.
   virtual void LogPasswordReuseDetectedEvent() = 0;
--- a/components/password_manager/core/browser/password_reuse_detection_manager.cc
+++ b/components/password_manager/core/browser/password_reuse_detection_manager.cc
@@ -161,9 +161,11 @@ void PasswordReuseDetectionManager::OnRe
                              ? reused_protected_password_hash->username
                              : "";
 
+  #if defined(PASSWORD_REUSE_DETECTION_ENABLED)
   client_->CheckProtectedPasswordEntry(reused_password_type, username,
                                        matching_reused_credentials,
                                        password_field_detected);
+  #endif
 }
 
 void PasswordReuseDetectionManager::SetClockForTesting(base::Clock* clock) {
--- a/components/safe_browsing/content/browser/client_side_detection_host.cc
+++ b/components/safe_browsing/content/browser/client_side_detection_host.cc
@@ -152,12 +152,6 @@ class ClientSideDetectionHost::ShouldCla
       DontClassifyForPhishing(NO_CLASSIFY_OFF_THE_RECORD);
     }
 
-    // Don't start classification if |url_| is allowlisted by enterprise policy.
-    if (host_->delegate_->GetPrefs() &&
-        IsURLAllowlistedByPolicy(url_, *host_->delegate_->GetPrefs())) {
-      DontClassifyForPhishing(NO_CLASSIFY_ALLOWLISTED_BY_POLICY);
-    }
-
     // If the tab has a delayed warning, ignore this second verdict. We don't
     // want to immediately undelay a page that's already blocked as phishy.
     if (host_->delegate_->HasSafeBrowsingUserInteractionObserver()) {
@@ -342,19 +336,17 @@ class ClientSideDetectionHost::ShouldCla
 std::unique_ptr<ClientSideDetectionHost> ClientSideDetectionHost::Create(
     content::WebContents* tab,
     std::unique_ptr<Delegate> delegate,
-    PrefService* pref_service,
     std::unique_ptr<SafeBrowsingTokenFetcher> token_fetcher,
     bool is_off_the_record,
     const PrimaryAccountSignedIn& account_signed_in_callback) {
   return base::WrapUnique(new ClientSideDetectionHost(
-      tab, std::move(delegate), pref_service, std::move(token_fetcher),
+      tab, std::move(delegate), std::move(token_fetcher),
       is_off_the_record, account_signed_in_callback));
 }
 
 ClientSideDetectionHost::ClientSideDetectionHost(
     WebContents* tab,
     std::unique_ptr<Delegate> delegate,
-    PrefService* pref_service,
     std::unique_ptr<SafeBrowsingTokenFetcher> token_fetcher,
     bool is_off_the_record,
     const PrimaryAccountSignedIn& account_signed_in_callback)
@@ -364,12 +356,10 @@ ClientSideDetectionHost::ClientSideDetec
       classification_request_(nullptr),
       tick_clock_(base::DefaultTickClock::GetInstance()),
       delegate_(std::move(delegate)),
-      pref_service_(pref_service),
       token_fetcher_(std::move(token_fetcher)),
       is_off_the_record_(is_off_the_record),
       account_signed_in_callback_(account_signed_in_callback) {
   DCHECK(tab);
-  DCHECK(pref_service);
   // Note: csd_service_ and sb_service will be nullptr here in testing.
   csd_service_ = delegate_->GetClientSideDetectionService();
 
@@ -544,19 +534,6 @@ void ClientSideDetectionHost::PhishingDe
                                                 GetDebugFeatureDirectory()));
     }
 
-    if (!IsExtendedReportingEnabled(*delegate_->GetPrefs()) &&
-        !IsEnhancedProtectionEnabled(*delegate_->GetPrefs())) {
-      // These fields should only be set for SBER users.
-      verdict->clear_screenshot_digest();
-      verdict->clear_screenshot_phash();
-      verdict->clear_phash_dimension_size();
-    }
-
-    if (IsEnhancedProtectionEnabled(*delegate_->GetPrefs()) &&
-        base::FeatureList::IsEnabled(kClientSideDetectionReferrerChain)) {
-      delegate_->AddReferrerChain(verdict.get(), current_url_);
-    }
-
     base::UmaHistogramBoolean("SBClientPhishing.LocalModelDetectsPhishing",
                               verdict->is_phishing());
 
@@ -650,13 +627,7 @@ void ClientSideDetectionHost::Initialize
 }
 
 bool ClientSideDetectionHost::CanGetAccessToken() {
-  if (is_off_the_record_)
-    return false;
-
-  // Return true if the primary user account of an ESB user is signed in.
-  return IsEnhancedProtectionEnabled(*pref_service_) &&
-         !account_signed_in_callback_.is_null() &&
-         account_signed_in_callback_.Run();
+  return false;
 }
 
 void ClientSideDetectionHost::SendRequest(
--- a/components/safe_browsing/content/browser/client_side_detection_host.h
+++ b/components/safe_browsing/content/browser/client_side_detection_host.h
@@ -19,7 +19,6 @@
 #include "components/safe_browsing/content/common/safe_browsing.mojom.h"
 #include "components/safe_browsing/core/browser/db/database_manager.h"
 #include "components/safe_browsing/core/browser/safe_browsing_token_fetcher.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 #include "content/public/browser/web_contents_observer.h"
 #include "mojo/public/cpp/bindings/remote.h"
 #include "services/service_manager/public/cpp/binder_registry.h"
@@ -51,8 +50,6 @@ class ClientSideDetectionHost : public c
 
     // Returns whether there is a SafeBrowsingUserInteractionObserver available.
     virtual bool HasSafeBrowsingUserInteractionObserver() = 0;
-    // Returns the prefs service associated with the current embedders profile.
-    virtual PrefService* GetPrefs() = 0;
     virtual scoped_refptr<SafeBrowsingDatabaseManager>
     GetSafeBrowsingDBManager() = 0;
     virtual scoped_refptr<BaseUIManager> GetSafeBrowsingUIManager() = 0;
@@ -70,7 +67,6 @@ class ClientSideDetectionHost : public c
   static std::unique_ptr<ClientSideDetectionHost> Create(
       content::WebContents* tab,
       std::unique_ptr<Delegate> delegate,
-      PrefService* pref_service,
       std::unique_ptr<SafeBrowsingTokenFetcher> token_fetcher,
       bool is_off_the_record,
       const PrimaryAccountSignedIn& account_signed_in_callback);
@@ -95,7 +91,6 @@ class ClientSideDetectionHost : public c
   explicit ClientSideDetectionHost(
       content::WebContents* tab,
       std::unique_ptr<Delegate> delegate,
-      PrefService* pref_service,
       std::unique_ptr<SafeBrowsingTokenFetcher> token_fetcher,
       bool is_off_the_record,
       const PrimaryAccountSignedIn& account_signed_in_callback);
@@ -209,9 +204,6 @@ class ClientSideDetectionHost : public c
 
   std::unique_ptr<Delegate> delegate_;
 
-  // Unowned object used for getting preference settings.
-  raw_ptr<PrefService> pref_service_;
-
   // The token fetcher used for getting access token.
   std::unique_ptr<SafeBrowsingTokenFetcher> token_fetcher_;
 
--- a/components/safe_browsing/content/browser/client_side_detection_service.cc
+++ b/components/safe_browsing/content/browser/client_side_detection_service.cc
@@ -84,18 +84,6 @@ ClientSideDetectionService::ClientSideDe
   url_loader_factory_ = delegate_->GetSafeBrowsingURLLoaderFactory();
 
   pref_change_registrar_.Init(delegate_->GetPrefs());
-  pref_change_registrar_.Add(
-      prefs::kSafeBrowsingEnabled,
-      base::BindRepeating(&ClientSideDetectionService::OnPrefsUpdated,
-                          base::Unretained(this)));
-  pref_change_registrar_.Add(
-      prefs::kSafeBrowsingEnhanced,
-      base::BindRepeating(&ClientSideDetectionService::OnPrefsUpdated,
-                          base::Unretained(this)));
-  pref_change_registrar_.Add(
-      prefs::kSafeBrowsingScoutReportingEnabled,
-      base::BindRepeating(&ClientSideDetectionService::OnPrefsUpdated,
-                          base::Unretained(this)));
   // Do an initial check of the prefs.
   OnPrefsUpdated();
 }
@@ -110,10 +98,8 @@ void ClientSideDetectionService::Shutdow
 
 void ClientSideDetectionService::OnPrefsUpdated() {
   DCHECK_CURRENTLY_ON(BrowserThread::UI);
-  bool enabled = IsSafeBrowsingEnabled(*delegate_->GetPrefs());
-  bool extended_reporting =
-      IsEnhancedProtectionEnabled(*delegate_->GetPrefs()) ||
-      IsExtendedReportingEnabled(*delegate_->GetPrefs());
+  bool enabled = false;
+  bool extended_reporting = false;
   if (enabled == enabled_ && extended_reporting_ == extended_reporting)
     return;
 
@@ -407,7 +393,6 @@ void ClientSideDetectionService::AddPhis
   base::ListValue time_list;
   for (const base::Time& report_time : phishing_report_times_)
     time_list.Append(base::Value(report_time.ToDoubleT()));
-  delegate_->GetPrefs()->Set(prefs::kSafeBrowsingCsdPingTimestamps, time_list);
 }
 
 void ClientSideDetectionService::LoadPhishingReportTimesFromPrefs() {
@@ -415,13 +400,6 @@ void ClientSideDetectionService::LoadPhi
     return;
 
   phishing_report_times_.clear();
-  for (const base::Value& timestamp :
-       delegate_->GetPrefs()
-           ->GetList(prefs::kSafeBrowsingCsdPingTimestamps)
-           ->GetList()) {
-    phishing_report_times_.push_back(
-        base::Time::FromDoubleT(timestamp.GetDouble()));
-  }
 }
 
 // static
--- a/components/safe_browsing/content/common/proto/BUILD.gn
+++ b/components/safe_browsing/content/common/proto/BUILD.gn
@@ -5,8 +5,12 @@
 import("//components/safe_browsing/buildflags.gni")
 import("//third_party/protobuf/proto_library.gni")
 
-if (safe_browsing_mode != 0) {
+# Although this was gated on safe_browsing_mode != 0, a considerable amount
+# of source code that relies on the types included in download_file_types.pb.h
+# is not gated on BUILDFLAG(SAFE_BROWSING_AVAILABLE). This is far less
+# invasive than the alternative.
+# if (safe_browsing_mode != 0) {
   proto_library("download_file_types_proto") {
     sources = [ "download_file_types.proto" ]
   }
-}
+# }
--- a/components/safe_browsing/content/common/safe_browsing.mojom
+++ b/components/safe_browsing/content/common/safe_browsing.mojom
@@ -120,7 +120,6 @@ enum PhishingDetectorResult {
   INVALID_SCORE = 4,
 };
 
-[EnableIf=full_safe_browsing]
 // Interface for setting the CSD model and to start phishing classification.
 interface PhishingDetector {
   // A classification model for client-side phishing detection.
--- a/components/safe_browsing/core/browser/user_population.cc
+++ b/components/safe_browsing/core/browser/user_population.cc
@@ -7,29 +7,13 @@
 #include "base/feature_list.h"
 #include "components/prefs/pref_service.h"
 #include "components/safe_browsing/core/common/features.h"
-#include "components/safe_browsing/core/common/safe_browsing_prefs.h"
 #include "components/safe_browsing/core/common/utils.h"
 #include "components/unified_consent/pref_names.h"
 #include "components/version_info/version_info.h"
 
 namespace safe_browsing {
 
-ChromeUserPopulation::UserPopulation GetUserPopulationPref(PrefService* prefs) {
-  if (prefs) {
-    if (IsEnhancedProtectionEnabled(*prefs)) {
-      return ChromeUserPopulation::ENHANCED_PROTECTION;
-    } else if (IsExtendedReportingEnabled(*prefs)) {
-      return ChromeUserPopulation::EXTENDED_REPORTING;
-    } else if (IsSafeBrowsingEnabled(*prefs)) {
-      return ChromeUserPopulation::SAFE_BROWSING;
-    }
-  }
-
-  return ChromeUserPopulation::UNKNOWN_USER_POPULATION;
-}
-
 ChromeUserPopulation GetUserPopulation(
-    PrefService* prefs,
     bool is_incognito,
     bool is_history_sync_enabled,
     bool is_under_advanced_protection,
@@ -39,13 +23,6 @@ ChromeUserPopulation GetUserPopulation(
     absl::optional<size_t> num_open_profiles) {
   ChromeUserPopulation population;
 
-  population.set_user_population(GetUserPopulationPref(prefs));
-
-  if (prefs) {
-    population.set_is_mbb_enabled(prefs->GetBoolean(
-        unified_consent::prefs::kUrlKeyedAnonymizedDataCollectionEnabled));
-  }
-
   population.set_is_incognito(is_incognito);
 
   population.set_is_history_sync_enabled(is_history_sync_enabled);
--- a/components/safe_browsing/core/browser/user_population.h
+++ b/components/safe_browsing/core/browser/user_population.h
@@ -21,8 +21,6 @@ ChromeUserPopulation::UserPopulation Get
 
 // Creates a ChromeUserPopulation proto for the given state.
 ChromeUserPopulation GetUserPopulation(
-    // The below may be null.
-    PrefService* prefs,
     bool is_incognito,
     bool is_history_sync_enabled,
     bool is_under_advanced_protection,
--- a/content/browser/file_system_access/safe_move_helper.cc
+++ b/content/browser/file_system_access/safe_move_helper.cc
@@ -151,14 +151,8 @@ void SafeMoveHelper::Start(SafeMoveHelpe
     return;
   }
 
-  if (!RequireSecurityChecks() || !manager_->permission_context()) {
-    DidAfterWriteCheck(
-        FileSystemAccessPermissionContext::AfterWriteCheckResult::kAllow);
-    return;
-  }
-
-  ComputeHashForSourceFile(base::BindOnce(&SafeMoveHelper::DoAfterWriteCheck,
-                                          weak_factory_.GetWeakPtr()));
+  DidAfterWriteCheck(
+      FileSystemAccessPermissionContext::AfterWriteCheckResult::kAllow);
 }
 
 void SafeMoveHelper::ComputeHashForSourceFile(HashCallback callback) {
@@ -178,38 +172,6 @@ void SafeMoveHelper::ComputeHashForSourc
                      std::move(wrapped_callback), source_url()));
 }
 
-void SafeMoveHelper::DoAfterWriteCheck(base::File::Error hash_result,
-                                       const std::string& hash,
-                                       int64_t size) {
-  DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
-
-  if (hash_result != base::File::FILE_OK) {
-    // Calculating the hash failed.
-    std::move(callback_).Run(file_system_access_error::FromStatus(
-        blink::mojom::FileSystemAccessStatus::kOperationAborted,
-        "Failed to perform Safe Browsing check."));
-    return;
-  }
-
-  if (!manager_) {
-    std::move(callback_).Run(file_system_access_error::FromStatus(
-        blink::mojom::FileSystemAccessStatus::kOperationAborted));
-    return;
-  }
-
-  auto item = std::make_unique<FileSystemAccessWriteItem>();
-  item->target_file_path = dest_url().path();
-  item->full_path = source_url().path();
-  item->sha256_hash = hash;
-  item->size = size;
-  item->frame_url = context_.url;
-  item->has_user_gesture = has_transient_user_activation_;
-  manager_->permission_context()->PerformAfterWriteChecks(
-      std::move(item), context_.frame_id,
-      base::BindOnce(&SafeMoveHelper::DidAfterWriteCheck,
-                     weak_factory_.GetWeakPtr()));
-}
-
 void SafeMoveHelper::DidAfterWriteCheck(
     FileSystemAccessPermissionContext::AfterWriteCheckResult result) {
   DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
--- a/content/browser/file_system_access/safe_move_helper.h
+++ b/content/browser/file_system_access/safe_move_helper.h
@@ -52,9 +52,6 @@ class CONTENT_EXPORT SafeMoveHelper {
  private:
   SEQUENCE_CHECKER(sequence_checker_);
 
-  void DoAfterWriteCheck(base::File::Error hash_result,
-                         const std::string& hash,
-                         int64_t size);
   void DidAfterWriteCheck(
       FileSystemAccessPermissionContext::AfterWriteCheckResult result);
   void DidFileSkipQuarantine(base::File::Error result);
--- a/content/public/browser/file_system_access_permission_context.h
+++ b/content/public/browser/file_system_access_permission_context.h
@@ -107,12 +107,6 @@ class FileSystemAccessPermissionContext
       base::OnceCallback<void(SensitiveDirectoryResult)> callback) = 0;
 
   enum class AfterWriteCheckResult { kAllow, kBlock };
-  // Runs a recently finished write operation through checks such as malware
-  // or other security checks to determine if the write should be allowed.
-  virtual void PerformAfterWriteChecks(
-      std::unique_ptr<FileSystemAccessWriteItem> item,
-      GlobalRenderFrameHostId frame_id,
-      base::OnceCallback<void(AfterWriteCheckResult)> callback) = 0;
 
   // Returns whether the give |origin| already allows read permission, or it is
   // possible to request one. This is used to block file dialogs from being
--- a/extensions/browser/updater/update_service.cc
+++ b/extensions/browser/updater/update_service.cc
@@ -115,13 +115,6 @@ void UpdateService::OnEvent(Events event
       break;
   }
 
-  if (should_perform_action_on_omaha_attributes) {
-    base::Value attributes = GetExtensionOmahaAttributes(extension_id);
-    // Note that it's important to perform actions even if |attributes| is
-    // empty, missing values may default to false and have associated logic.
-    ExtensionSystem::Get(browser_context_)
-        ->PerformActionBasedOnOmahaAttributes(extension_id, attributes);
-  }
 }
 
 UpdateService::UpdateService(
--- a/weblayer/BUILD.gn
+++ b/weblayer/BUILD.gn
@@ -461,7 +461,6 @@ source_set("weblayer_lib_base") {
     "//components/prefs",
     "//components/profile_metrics",
     "//components/safe_browsing/content/browser",
-    "//components/safe_browsing/content/browser:client_side_detection",
     "//components/safe_browsing/content/common:interfaces",
     "//components/safe_browsing/content/renderer:throttles",
     "//components/safe_browsing/content/renderer/phishing_classifier",
